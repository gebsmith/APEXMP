# -*- coding: utf-8 -*-
#############################################################################
############################## PROGRAM METADATA #############################
#############################################################################

# Last Updated by: Ryan McGehee
# Last Updated on: 10 November 2020
# Purpose: This program is designed to run combinations of APEX input files
#          in a parallel configuration.
# Contributors: Qingyu Feng (provided seperate sets of code for each data
#               which was merged and modified from his original script). 
#               Feng combined these functions in a single script and Ryan
#               refactored and tested the final code.


#############################################################################
############################# INSTRUCTIONS TO RUN ###########################
#############################################################################

# Requirements: Place this script in the ./APEXMP/SRC directory. 
#               Requires gdal module (python 3.x version preferred).
#               All data must be in the ./APEXMP/INPUTS directory along with
#               the following:
#
# Files or directory:    
#           apex1501.exe                (the version of APEX you want to run)
#           REQUIRED directory          (provided with this package)
#           INPUTS directory            (directories of dem, lanuse, slope, 
#                                       and soil; soil-database file)
#           MPRUNS                      (will be generated by the code to storage
#                                       results of each apex run)
#           RESULTS                     (will be generated by the code to storage
#                                       the output file of the entire code run)
#
# Disk Space: At least 4 MB of space per run is required for keeping all run
#             outputs. The requirement is much smaller if one does not need to 
#             preserve the monthly, average monthly, average annualand output files. 
#             This code can be modified to remove those files after each run in 
#             order to increase run limits.


##############################################################################
############################## IMPORT LIBRARIES ##############################
##############################################################################

import datetime
import math
import os, re
import shutil
import signal
import string
import subprocess
import sys
import glob
import pandas as pd
import xml.etree.ElementTree as ET

from datetime import timedelta
from multiprocessing import cpu_count, Pool, Process
from shutil import copyfile
from subprocess import Popen,PIPE

#############################################################################
############################## GLOBAL VARIABLES #############################
#############################################################################

workdir = sys.argv[1]
delete = sys.argv[2]
verb = sys.argv[3]
ubmp = sys.argv[4]
bmps = sys.argv[5]
devm = sys.argv[6]
nworkers = sys.argv[7]

#############################################################################
############################## DEFINE FUNCTIONS #############################
#############################################################################

def readAsc(filename):
    
    #This function read the asc files into dataframe
    try:
        fid = open(filename, "r")
    except:
        print("File %s does not exist!!!" %(filename))
    
    header = []
    tmpline = []
    
    #read the metadata: 
    # [0]ncols, [1]nrows, [2]xllcorner, [3]yllcorner, [-2]cellsize, [-1]NODATA_value 0
    # (for decimal projection, there could be tiny different size of x and y,
    #  so there could be xcellsize and ycellsize which takes two rows) 

    for i in range (7):
        tmpline = fid.readline()
        tmpline = tmpline.split(" ")
        while "" in tmpline:
            tmpline.remove("")
        if (len(tmpline) == 2):      
            tmpline[-1] = tmpline[-1][:-1]    
            header.append(tmpline)

    #read the data    
    tmpline2 = ""
    data = []
    for j in range (int(header[1][1])):
        tmpline2 = fid.readline()  
        tmpline2 = tmpline2.split(" ")
        while "" in tmpline2:
            tmpline2.remove("")
        if (len(tmpline2) > 2):
            tmpline2[-1] = tmpline2[-1][:-1]
        data.append(tmpline2)
    
    fid.close()

    return header, data

def createHrus(slopearray,
                landusearray,
                soilarray,
                demarray,
                slpheader,
                luheader,
                solheader,
                demheader):

    # This is a loop through all arrays. An array will be created to store all of the hru inputs. 
    # An hru here will have dem, soil, landuse, and slope. 

    hrulist = {}
	# avoid the boundary
    for rowidx in range(len(landusearray)-2):
        for colidx in range(len(landusearray[rowidx])-2):
            if ((slopearray[rowidx][colidx] != "-1.#QNAN")
                and (slopearray[rowidx][colidx] != "1.#QNAN")):  
                
                # get the longitude and latitude from the ascii data metadata
                # [0]ncols, [1]nrows, [2]xllcorner, [3]yllcorner, [-2]cellsize, [-1]NODATA_value 0
                # (for decimal projection, there could be tiny different size of x and y,
                #  so there could be xcellsize and ycellsize which takes two rows), 
                
                lat = float(float(luheader[3][1])+float(luheader[-2][1])*(int(luheader[1][1])-int(rowidx)))
                lon = float(float(luheader[2][1])+float(luheader[-2][1])*int(colidx))                              

                # If not no data cells,
                if ((str(int(float(soilarray[rowidx][colidx]))) != solheader[-1][1])
                    and (str(int(float(landusearray[rowidx][colidx]))) != luheader[-1][1])
                    and (str(int(float(slopearray[rowidx][colidx]))) != slpheader[-1][1])
                    and (str(int(float(demarray[rowidx][colidx]))) != demheader[-1][1])):

                    #[0latitude, 1longitude, 2soil, 3landuse, 4slope, 5dem]
                    hrulist[str(rowidx)+"_"+str(colidx)] = [lat,
                                                            lon,
                                                            soilarray[rowidx][colidx],
                                                            landusearray[rowidx][colidx],
                                                            abs(float(slopearray[rowidx][colidx])),
                                                            abs(float(demarray[rowidx][colidx]))]
    
    return hrulist

def ctyData():

    # Read slope
    fnslpasc = os.path.join(workdir + "\\INPUTS\\slope\\asc",
                                    "slp.asc")
    slpheader, slopearray = readAsc(fnslpasc)
    
    # Read land use
    fnluasc = os.path.join(workdir + "\\INPUTS\\landuse\\asc",
                                    "lu.asc")        
    luheader, landusearray = readAsc(fnluasc)
    
    # Read Soil
    fnsolasc = os.path.join(workdir + "\\INPUTS\\soil\\asc",
                                    "sol.asc")                                  
    solheader, soilarray = readAsc(fnsolasc)
    
    # Read dem
    fndemasc = os.path.join(workdir + "\\INPUTS\\dem\\asc",
                                    "dem.asc")                                 
    demheader, demarray = readAsc(fndemasc)

    # After reading the raster files into the arrays, the next step 
    # is to overlap them.
    hrulsts = createHrus(slopearray,
                        landusearray,
                        soilarray,
                        demarray,
                        slpheader,
                        luheader,
                        solheader,
                        demheader)

    return hrulsts

def getUplandManningN(landuse):
        
        # There are 9 values for land use, and their corresponding
        # manning's n will be assigned as:
        # 1. corn: 0.13
        # 2. soybean: 0.13
        # 3. Wheat: 0.13
        # 4. Hay: 0.15
        # 5. Pasture: 0.15
        # 6. Urban: 0.01
        # 7. Forest: 0.41
        # 8. Water: 0.01
        # 9. Other agriculture: 0.13
        manningn = 0
        
        if (landuse in [1, 2, 3, 9]):
            manningn = 0.13
        elif (landuse in [4, 5]):
            manningn = 0.15
        elif (landuse in [6, 8]):
            manningn = 0.01
        elif (landuse == 7):
            manningn = 0.41
        else:
            manningn = 0.15
            
        return manningn

def modifySubFile(hruinvar, idx, soldb):

    # Change to current run directory and read .sub file.
    os.chdir(workdir + "\\MPRUNS\\everyhru_map\\" + str(idx))

    #[0latitude, 1longitude, 2soil, 3landuse, 4slope, 5dem, 6rowid_colid, 7bmpid]
   
    selectdata = soldb.loc[soldb['mukey'] == int(hruinvar[2])]
    soldata = selectdata.to_dict('records')

    hsgnumb = 0
    hsgnumb = hsgLetter2Num(soldata[0]["hydgrpdcd"])

    f = open("SUB.SUB","r")
    fstr = f.read()
    f.close()

    # Modify the sub file with new values.

    if (len(hruinvar) == 8):
        fstr = fstr.replace("__opsid__",str(int(hruinvar[7])))
    else:
        fstr = fstr.replace("__opsid__",str(int(hruinvar[3])))
    fstr = fstr.replace("__latitude__",str(round(float(hruinvar[0]),7)))
    fstr = fstr.replace("__longitude__",str(round(float(hruinvar[1]),7)))
    fstr = fstr.replace("__wsa_ha__",str(0.09))  
    fstr = fstr.replace("__chl__",str(round(float(soldata[0]["slopelenusle_r"]),3))) 
    fstr = fstr.replace("__chs__",str(round(float(hruinvar[4]),3)))
    fstr = fstr.replace("__slp__",str(round(float(hruinvar[4]),3)))  
    fstr = fstr.replace("__splg__",str(round(float(soldata[0]["slopelenusle_r"]),3)))  
    fstr = fstr.replace("__upn__",str(round(float(getUplandManningN(hruinvar[3])),3)))   
    fstr = fstr.replace("__rchl__",str(round(float(soldata[0]["slopelenusle_r"]),3)))  
    fstr = fstr.replace("__rchs__",str(round(float(hruinvar[4]),3))) 

    if (hsgnumb == 3 or hsgnumb == 4 and hruinvar[4] < 0.02):
        fstr = fstr.replace("__ddi__",str(1000.0))
        fstr = fstr.replace("__dde__",str(3))
    else:
        fstr = fstr.replace("__ddi__",str(0.00))
        fstr = fstr.replace("__dde__",str(0.00))
 
    # Write the new sub file.
    outf = open("SUB.SUB","w")
    outf.write(fstr)
    outf.close()

def modifySitFile(hruinvar, idx, soldb):
    
    # Change to current run directory and read .sit file.
    os.chdir(workdir + "\\MPRUNS\\everyhru_map\\" + str(idx))

    #[0latitude, 1longitude, 2soil, 3landuse, 4slope, 5dem, 6rowid_colid, 7bmpid]

    selectdata = soldb.loc[soldb['mukey'] == int(hruinvar[2])]
    soldata = selectdata.to_dict('records')

    f = open("SIT.SIT","r")
    fstr = f.read()
    f.close()

    # Modify the sit file with new values.
    fstr = fstr.replace("__latitude__",str(round(float(hruinvar[0]),2)))
    fstr = fstr.replace("__longitude__",str(round(float(hruinvar[1]),2)))
    fstr = fstr.replace("__elev__",str(round(float(hruinvar[5]),2)))
    fstr = fstr.replace("__bchl__",str(round(float(soldata[0]["slopelenusle_r"]),2)))  
    fstr = fstr.replace("__bchs__",str(round(float(hruinvar[4]),2)))  

    # Write the new sit file.
    outf = open("SIT.SIT","w")
    outf.write(fstr)
    outf.close()

def hsgLetter2Num(letter):
    
    if "/" in letter:
        letter = letter.split("/")[0]
        
    if letter == "A":
        numb = 1
    elif letter == "B":
        numb = 2
    elif letter == "C":
        numb = 3
    else:
        numb = 4
        
    return numb

def modifySolFile(hruinvar, idx, soldb):

    # Change to current run directory and read .sol file.    
    os.chdir(workdir + "\\MPRUNS\\everyhru_map\\" + str(idx))
    #[0latitude, 1longitude, 2soil, 3landuse, 4slope, 5dem, 6rowid_colid, 7bmpid]
       
    selectdata = soldb.loc[soldb['mukey'] == int(hruinvar[2])]
    soldata = selectdata.to_dict('records')

    # Modify the first two lines of sol file with new values.
    
    # Update line 1: desctiption
    # Update line 2
    hsgnumb = 0
    hsgnumb = hsgLetter2Num(soldata[0]["hydgrpdcd"])
    # No need to update Line 3:  Same format as line 2, different parameters. 
    # Some values were set to prevent any potential model run failure.
    # the 5th variable ZQT, should be from 0.01 to 0.25.
    # the 6th and 7th variable ZF should be from 0.05 to 0.25
    # the 8 and 9 should be larger than 0.03 and 0.3
    # The 10th should be left blank
    outf = open("SOL.SOL","w")
    fstr1 = "%20s\n" %(soldata[0]["muname"])
    outf.writelines(fstr1)
    fstr2 = "%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f\n"\
                        %(float(soldata[0]["albedodry_r"]),\
                          float(hsgnumb), 0.00,\
                          float(soldata[0]["wtdepannmin"]),\
                          0.00, 0.00, 0.00, 0.00, 0.00, 0.00)
    outf.writelines(fstr2)
    fstr3 = "%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f        \n"\
                    %(10.00, 
                        0.00, 
                        50.00,
                        2.00,
                        0.01,
                        0.05,
                        0.05,
                        0.03,
                        0.30
                        )
    outf.writelines(fstr3)
    # Writing line 4 to 51 of sol file with new values
    # Starting from line 4, the variables will be writen for 
    # properties for eacy layer, and each column represent one layer.
    # It is better to use a loop to do the writing.

    sol_layer_pro = [""]*52
    layeridxlst = []
    layeridxlst = [int(float(soldata[0]["l1_layerid"])),
                    int(float(soldata[0]["l2_layerid"])),
                    int(float(soldata[0]["l3_layerid"])),
                    int(float(soldata[0]["l4_layerid"])),
                    int(float(soldata[0]["l5_layerid"])),
                    int(float(soldata[0]["l6_layerid"])),
                    int(float(soldata[0]["l7_layerid"])),
                    int(float(soldata[0]["l8_layerid"])),
                    int(float(soldata[0]["l9_layerid"])),
                    int(float(soldata[0]["l10_layerid"]))
                ]
    extra = {}
    extra = {"l1_cnds":float(5.00),
            "l2_cnds":float(2.50),
            "l3_cnds":float(2.50),
            "l4_cnds":float(0.00),
            "l5_cnds":float(0.00),
            "l6_cnds":float(0.00),
            "l7_cnds":float(0.00),
            "l8_cnds":float(0.00),
            "l9_cnds":float(0.00),
            "l10_cnds":float(0.00)
            }   
    
    for layeridx in range(0, max(layeridxlst)):
        if layeridx < max(layeridxlst)-1:
            #  !  4  Z    = DEPTH TO BOTTOM OF LAYERS(m)            
                    sol_layer_pro[3] = sol_layer_pro[3] + "%8.2f" \
                        %(float(soldata[0]["l%i_layerdepth" %(layeridx+1)])/100)
            #  !  5  BD   = BULK DENSITY(t/m3)                
                    sol_layer_pro[4] = sol_layer_pro[4] + "%8.2f" \
                        %(float(soldata[0]["l%i_bulkdensity" %(layeridx+1)]))
            #  !  6  UW   = SOIL WATER CONTENT AT WILTING POINT(1500 KPA)(m/m)                                             
            #  !            (BLANK IF UNKNOWN)                
                    sol_layer_pro[5] = sol_layer_pro[5] + "%8.2f" \
                        %(float(soldata[0]["l%i_wiltingpoint" %(layeridx+1)])/100)
            #  !  7  FC   = WATER CONTENT AT FIELD CAPACITY(33KPA)(m/m)                                                    
            #  !            (BLANK IF UNKNOWN)                
                    sol_layer_pro[6] = sol_layer_pro[6] + "%8.2f" \
                        %(float(soldata[0]["l%i_fieldcapacity" %(layeridx+1)])/100)
            #  !  8  SAN  = % SAND                 
                    sol_layer_pro[7] = sol_layer_pro[7] + "%8.2f" \
                        %(float(soldata[0]["l%i_sandtotal" %(layeridx+1)]))
            #  !  9  SIL  = % SILT                
                    sol_layer_pro[8] = sol_layer_pro[8] + "%8.2f" \
                        %(float(soldata[0]["l%i_silttotal" %(layeridx+1)]))
            #  ! 10  WN   = INITIAL ORGANIC N CONC(g/t)       (BLANK IF UNKNOWN)                
                    sol_layer_pro[9] = sol_layer_pro[9] + "%8.2f" \
                        %(0.00)
            #  ! 11  PH   = SOIL PH                
                    sol_layer_pro[10] = sol_layer_pro[10] + "%8.2f" \
                        %(float(soldata[0]["l%i_ph" %(layeridx+1)]))
            #  ! 12  SMB  = SUM OF BASES(cmol/kg)              (BLANK IF UNKNOWN)
                    sol_layer_pro[11] = sol_layer_pro[11] + "%8.2f" \
                        %(float(soldata[0]["l%i_sumofbases" %(layeridx+1)]))
            #  ! 13  WOC  = ORGANIC CARBON CONC(%)                
                    sol_layer_pro[12] = sol_layer_pro[12] + "%8.2f" \
                        %(float(soldata[0]["l%i_organicmatter" %(layeridx+1)]))
            #  ! 14  CAC  = CALCIUM CARBONATE(%)                 
                    sol_layer_pro[13] = sol_layer_pro[13] + "%8.2f" \
                        %(float(soldata[0]["l%i_caco3" %(layeridx+1)]))
            #  ! 15  CEC  = CATION EXCHANGE CAPACITY(cmol/kg)(BLANK IF UNKNOWN                
                    sol_layer_pro[14] = sol_layer_pro[14] + "%8.2f" \
                        %(float(soldata[0]["l%i_cec" %(layeridx+1)]))
            #  ! 16  ROK  = COARSE FRAGMENTS(% VOL)              (BLANK IF UNKNOWN)           
                    sol_layer_pro[15] = sol_layer_pro[15] + "%8.2f" \
                        %(100-float(soldata[0]["l%i_croasefragment" %(layeridx+1)]))
            #  ! 17  CNDS = INITIAL SOL N CONC(g/t)            (BLANK IF UNKNOWN) 
                    sol_layer_pro[16] = sol_layer_pro[16] + "%8.2f" \
                        %(float(extra["l%i_cnds" %(layeridx+1)]))
            #  ! 18  SSF  = INITIAL SOL P CONC(g/t)       (BLANK IF UNKNOWN)
                    sol_layer_pro[17] = sol_layer_pro[17] + "%8.2f" \
                        %(float(soldata[0]["l%i_ph2osoluble_r" %(layeridx+1)]))
            #  ! 19  RSD  = CROP RESIDUE(t/ha)                (BLANK IF UNKNOWN)   
                    sol_layer_pro[18] = sol_layer_pro[18] + "%8.2f" \
                        %(0.00)
            #  ! 20  BDD  = BULK DENSITY(OVEN DRY)(t/m3)   (BLANK IF UNKNOWN)                
                    sol_layer_pro[19] = sol_layer_pro[19] + "%8.2f" \
                        %(float(soldata[0]["l%i_drybulkdensity" %(layeridx+1)]))
            #  ! 21  PSP  = P SORPTION RATIO                   (BLANK IF UNKNOWN)                  
                    sol_layer_pro[20] = sol_layer_pro[20] + "%8.2f" \
                        %(0.00) 
            #  ! 22  SATC = SATURATED CONDUCTIVITY(mm/h)     (BLANK IF UNKNOWN)
                    sol_layer_pro[21] = sol_layer_pro[21] + "%8.2f" \
                        %(float(soldata[0]["l%i_ksat" %(layeridx+1)]))
            #  ! 23  HCL  = LATERAL HYDRAULIC CONDUCTIVITY(mm/h)                
                    sol_layer_pro[22] = sol_layer_pro[22] + "%8.2f" \
                        %(0.00)
            #  ! 24  WPO  = INITIAL ORGANIC P CONC(g/t)      (BLANK IF UNKNOWN)                
                    sol_layer_pro[23] = sol_layer_pro[23] + "%8.2f" \
                        %(float(soldata[0]["l%i_ptotal" %(layeridx+1)])-float(soldata[0]["l%i_ph2osoluble_r" %(layeridx+1)]))
            #  ! 25  DHN  = EXCHANGEABLE K CONC (g/t)                
                    sol_layer_pro[24] = sol_layer_pro[24] + "%8.2f" \
                        %(0.00)
            #  ! 26  ECND = ELECTRICAL COND (mmho/cm)                
                    sol_layer_pro[25] = sol_layer_pro[25] + "%8.2f" \
                        %(float(soldata[0]["l%i_ec" %(layeridx+1)]))
            #  ! 27  STFR = FRACTION OF STORAGE INTERACTING WITH NO3 LEACHING                                              
            #  !                                               (BLANK IF UNKNOWN)                
                    sol_layer_pro[26] = sol_layer_pro[26] + "%8.2f" \
                        %(0.00)
            #  ! 28  SWST = INITIAL SOIL WATER STORAGE (m/m)                
                    sol_layer_pro[27] = sol_layer_pro[27] + "%8.2f" \
                        %(0.00)
            #  ! 29  CPRV = FRACTION INFLOW PARTITIONED TO VERTICLE CRACK OR PIPE FLOW                
                    sol_layer_pro[28] = sol_layer_pro[28] + "%8.2f" \
                        %(0.00)
            #  ! 30  CPRH = FRACTION INFLOW PARTITIONED TO HORIZONTAL CRACK OR PIPE                                        
            #  !            FLOW                 
                    sol_layer_pro[29] = sol_layer_pro[29] + "%8.2f" \
                        %(0.00)
            #  ! 31  WLS  = STRUCTURAL LITTER(kg/ha)           (BLANK IF UNKNOWN)                
                    sol_layer_pro[30] = sol_layer_pro[30] + "%8.2f" \
                        %(0.00)
            #  ! 32  WLM  = METABOLIC LITTER(kg/ha)            (BLANK IF UNKNOWN)            
                    sol_layer_pro[31] = sol_layer_pro[31] + "%8.2f" \
                        %(0.00)
            #  ! 33  WLSL = LIGNIN CONTENT OF STRUCTURAL LITTER(kg/ha)(B I U)                
                    sol_layer_pro[32] = sol_layer_pro[32] + "%8.2f" \
                        %(0.00)
            #  ! 34  WLSC = CARBON CONTENT OF STRUCTURAL LITTER(kg/ha)(B I U) 
                    sol_layer_pro[33] = sol_layer_pro[33] + "%8.2f" \
                        %(0.00)
            #  ! 35  WLMC = C CONTENT OF METABOLIC LITTER(kg/ha)(B I U)
                    sol_layer_pro[34] = sol_layer_pro[34] + "%8.2f" \
                        %(0.00)
            #  ! 36  WLSLC= C CONTENT OF LIGNIN OF STRUCTURAL LITTER(kg/ha)(B I U)
                    sol_layer_pro[35] = sol_layer_pro[35] + "%8.2f" \
                        %(0.00)
            #  ! 37  WLSLNC=N CONTENT OF LIGNIN OF STRUCTURAL LITTER(kg/ha)(BIU)
                    sol_layer_pro[36] = sol_layer_pro[36] + "%8.2f" \
                        %(0.00)
            #  ! 38  WBMC = C CONTENT OF BIOMASS(kg/ha)(BIU)
                    sol_layer_pro[37] = sol_layer_pro[37] + "%8.2f" \
                        %(0.00)
            #  ! 39  WHSC = C CONTENT OF SLOW HUMUS(kg/ha)(BIU)
                    sol_layer_pro[38] = sol_layer_pro[38] + "%8.2f" \
                        %(0.00)
            #  ! 40  WHPC = C CONTENT OF PASSIVE HUMUS(kg/ha)(BIU)
                    sol_layer_pro[39] = sol_layer_pro[39] + "%8.2f" \
                        %(0.00)
            #  ! 41  WLSN = N CONTENT OF STRUCTURAL LITTER(kg/ha)(BIU)
                    sol_layer_pro[40] = sol_layer_pro[40] + "%8.2f" \
                        %(0.00)
            #  ! 42  WLMN = N CONTENT OF METABOLIC LITTER(kg/ha)(BIU)
                    sol_layer_pro[41] = sol_layer_pro[41] + "%8.2f" \
                        %(0.00)
            #  ! 43  WBMN = N CONTENT OF BIOMASS(kg/ha)(BIU)
                    sol_layer_pro[42] = sol_layer_pro[42] + "%8.2f" \
                        %(0.00)
            #  ! 44  WHSN = N CONTENT OF SLOW HUMUS(kg/ha)(BIU)
                    sol_layer_pro[43] = sol_layer_pro[43] + "%8.2f" \
                        %(0.00)
            #  ! 45  WHPN = N CONTENT OF PASSIVE HUMUS(kg/ha)(BIU)
                    sol_layer_pro[44] = sol_layer_pro[44] + "%8.2f" \
                        %(0.00)
            #  ! 46  FE26 = IRON CONTENT(%)
                    sol_layer_pro[45] = sol_layer_pro[45] + "%8.2f" \
                        %(0.00)
            #  ! 47  SULF = SULFUR CONTENT(%)                 
                    sol_layer_pro[46] = sol_layer_pro[46] + "%8.2f" \
                        %(0.00)
            #  ! 48  ASHZ = SOIL HORIZON(A,B,C)                                                                            
                    sol_layer_pro[47] = sol_layer_pro[47] + "%8s" \
                        %(" ")
            #   ! 49  CGO2 = O2 CONC IN GAS PHASE (g/m3 OF SOIL AIR)
                    sol_layer_pro[48] = sol_layer_pro[48] + "%8.2f" \
                        %(0.00)
            #   ! 50  CGCO2= CO2 CONC IN GAS PHASE (g/m3 OF SOIL AIR)                                                       
                    sol_layer_pro[49] = sol_layer_pro[49] + "%8.2f" \
                        %(0.00)
            #   ! 51  CGN2O= N2O CONC IN GAS PHASE (g/m3 OF SOIL AIR)                 
                    sol_layer_pro[50] = sol_layer_pro[50] + "%8.2f" \
                        %(0.00)
        else:
           #  !  4  Z    = DEPTH TO BOTTOM OF LAYERS(m)            
                    sol_layer_pro[3] = sol_layer_pro[3] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_layerdepth" %(layeridx+1)])/100)
            #  !  5  BD   = BULK DENSITY(t/m3)                
                    sol_layer_pro[4] = sol_layer_pro[4] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_bulkdensity" %(layeridx+1)]))
            #  !  6  UW   = SOIL WATER CONTENT AT WILTING POINT(1500 KPA)(m/m)                                             
            #  !            (BLANK IF UNKNOWN)                
                    sol_layer_pro[5] = sol_layer_pro[5] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_wiltingpoint" %(layeridx+1)])/100)
            #  !  7  FC   = WATER CONTENT AT FIELD CAPACITY(33KPA)(m/m)                                                    
            #  !            (BLANK IF UNKNOWN)                
                    sol_layer_pro[6] = sol_layer_pro[6] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_fieldcapacity" %(layeridx+1)])/100)
            #  !  8  SAN  = % SAND                 
                    sol_layer_pro[7] = sol_layer_pro[7] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_sandtotal" %(layeridx+1)]))
            #  !  9  SIL  = % SILT                
                    sol_layer_pro[8] = sol_layer_pro[8] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_silttotal" %(layeridx+1)]))
            #  ! 10  WN   = INITIAL ORGANIC N CONC(g/t)       (BLANK IF UNKNOWN)                
                    sol_layer_pro[9] = sol_layer_pro[9] + "%8.2f\n" \
                        %(0.00)
            #  ! 11  PH   = SOIL PH                
                    sol_layer_pro[10] = sol_layer_pro[10] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_ph" %(layeridx+1)]))
            #  ! 12  SMB  = SUM OF BASES(cmol/kg)              (BLANK IF UNKNOWN)
                    sol_layer_pro[11] = sol_layer_pro[11] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_sumofbases" %(layeridx+1)]))
            #  ! 13  WOC  = ORGANIC CARBON CONC(%)                
                    sol_layer_pro[12] = sol_layer_pro[12] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_organicmatter" %(layeridx+1)]))
            #  ! 14  CAC  = CALCIUM CARBONATE(%)                 
                    sol_layer_pro[13] = sol_layer_pro[13] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_caco3" %(layeridx+1)]))
            #  ! 15  CEC  = CATION EXCHANGE CAPACITY(cmol/kg)(BLANK IF UNKNOWN                
                    sol_layer_pro[14] = sol_layer_pro[14] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_cec" %(layeridx+1)]))
            #  ! 16  ROK  = COARSE FRAGMENTS(% VOL)              (BLANK IF UNKNOWN)           
                    sol_layer_pro[15] = sol_layer_pro[15] + "%8.2f\n" \
                        %(100-float(soldata[0]["l%i_croasefragment" %(layeridx+1)]))
            #  ! 17  CNDS = INITIAL SOL N CONC(g/t)            (BLANK IF UNKNOWN) 
                    sol_layer_pro[16] = sol_layer_pro[16] + "%8.2f\n" \
                        %(float(extra["l%i_cnds" %(layeridx+1)]))
            #  ! 18  SSF  = INITIAL SOL P CONC(g/t)       (BLANK IF UNKNOWN)
                    sol_layer_pro[17] = sol_layer_pro[17] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_ph2osoluble_r" %(layeridx+1)]))
            #  ! 19  RSD  = CROP RESIDUE(t/ha)                (BLANK IF UNKNOWN)   
                    sol_layer_pro[18] = sol_layer_pro[18] + "%8.2f\n" \
                        %(0.00)
            #  ! 20  BDD  = BULK DENSITY(OVEN DRY)(t/m3)   (BLANK IF UNKNOWN)                
                    sol_layer_pro[19] = sol_layer_pro[19] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_drybulkdensity" %(layeridx+1)]))
            #  ! 21  PSP  = P SORPTION RATIO                   (BLANK IF UNKNOWN)                  
                    sol_layer_pro[20] = sol_layer_pro[20] + "%8.2f\n" \
                        %(0.00) 
            #  ! 22  SATC = SATURATED CONDUCTIVITY(mm/h)     (BLANK IF UNKNOWN)
                    sol_layer_pro[21] = sol_layer_pro[21] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_ksat" %(layeridx+1)]))
            #  ! 23  HCL  = LATERAL HYDRAULIC CONDUCTIVITY(mm/h)                
                    sol_layer_pro[22] = sol_layer_pro[22] + "%8.2f\n" \
                        %(0.00)
            #  ! 24  WPO  = INITIAL ORGANIC P CONC(g/t)      (BLANK IF UNKNOWN)                
                    sol_layer_pro[23] = sol_layer_pro[23] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_ptotal" %(layeridx+1)])-float(soldata[0]["l%i_ph2osoluble_r" %(layeridx+1)]))
            #  ! 25  DHN  = EXCHANGEABLE K CONC (g/t)                
                    sol_layer_pro[24] = sol_layer_pro[24] + "%8.2f\n" \
                        %(0.00)
            #  ! 26  ECND = ELECTRICAL COND (mmho/cm)                
                    sol_layer_pro[25] = sol_layer_pro[25] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_ec" %(layeridx+1)]))
            #  ! 27  STFR = FRACTION OF STORAGE INTERACTING WITH NO3 LEACHING                                              
            #  !                                               (BLANK IF UNKNOWN)                
                    sol_layer_pro[26] = sol_layer_pro[26] + "%8.2f\n" \
                        %(0.00)
            #  ! 28  SWST = INITIAL SOIL WATER STORAGE (m/m)                
                    sol_layer_pro[27] = sol_layer_pro[27] + "%8.2f\n" \
                        %(0.00)
            #  ! 29  CPRV = FRACTION INFLOW PARTITIONED TO VERTICLE CRACK OR PIPE FLOW                
                    sol_layer_pro[28] = sol_layer_pro[28] + "%8.2f\n" \
                        %(0.00)
            #  ! 30  CPRH = FRACTION INFLOW PARTITIONED TO HORIZONTAL CRACK OR PIPE                                        
            #  !            FLOW                 
                    sol_layer_pro[29] = sol_layer_pro[29] + "%8.2f\n" \
                        %(0.00)
            #  ! 31  WLS  = STRUCTURAL LITTER(kg/ha)           (BLANK IF UNKNOWN)                
                    sol_layer_pro[30] = sol_layer_pro[30] + "%8.2f\n" \
                        %(0.00)
            #  ! 32  WLM  = METABOLIC LITTER(kg/ha)            (BLANK IF UNKNOWN)            
                    sol_layer_pro[31] = sol_layer_pro[31] + "%8.2f\n" \
                        %(0.00)
            #  ! 33  WLSL = LIGNIN CONTENT OF STRUCTURAL LITTER(kg/ha)(B I U)                
                    sol_layer_pro[32] = sol_layer_pro[32] + "%8.2f\n" \
                        %(0.00)
            #  ! 34  WLSC = CARBON CONTENT OF STRUCTURAL LITTER(kg/ha)(B I U) 
                    sol_layer_pro[33] = sol_layer_pro[33] + "%8.2f\n" \
                        %(0.00)
            #  ! 35  WLMC = C CONTENT OF METABOLIC LITTER(kg/ha)(B I U)
                    sol_layer_pro[34] = sol_layer_pro[34] + "%8.2f\n" \
                        %(0.00)
            #  ! 36  WLSLC= C CONTENT OF LIGNIN OF STRUCTURAL LITTER(kg/ha)(B I U)
                    sol_layer_pro[35] = sol_layer_pro[35] + "%8.2f\n" \
                        %(0.00)
            #  ! 37  WLSLNC=N CONTENT OF LIGNIN OF STRUCTURAL LITTER(kg/ha)(BIU)
                    sol_layer_pro[36] = sol_layer_pro[36] + "%8.2f\n" \
                        %(0.00)
            #  ! 38  WBMC = C CONTENT OF BIOMASS(kg/ha)(BIU)
                    sol_layer_pro[37] = sol_layer_pro[37] + "%8.2f\n" \
                        %(0.00)
            #  ! 39  WHSC = C CONTENT OF SLOW HUMUS(kg/ha)(BIU)
                    sol_layer_pro[38] = sol_layer_pro[38] + "%8.2f\n" \
                        %(0.00)
            #  ! 40  WHPC = C CONTENT OF PASSIVE HUMUS(kg/ha)(BIU)
                    sol_layer_pro[39] = sol_layer_pro[39] + "%8.2f\n" \
                        %(0.00)
            #  ! 41  WLSN = N CONTENT OF STRUCTURAL LITTER(kg/ha)(BIU)
                    sol_layer_pro[40] = sol_layer_pro[40] + "%8.2f\n" \
                        %(0.00)
            #  ! 42  WLMN = N CONTENT OF METABOLIC LITTER(kg/ha)(BIU)
                    sol_layer_pro[41] = sol_layer_pro[41] + "%8.2f\n" \
                        %(0.00)
            #  ! 43  WBMN = N CONTENT OF BIOMASS(kg/ha)(BIU)
                    sol_layer_pro[42] = sol_layer_pro[42] + "%8.2f\n" \
                        %(0.00)
            #  ! 44  WHSN = N CONTENT OF SLOW HUMUS(kg/ha)(BIU)
                    sol_layer_pro[43] = sol_layer_pro[43] + "%8.2f\n" \
                        %(0.00)
            #  ! 45  WHPN = N CONTENT OF PASSIVE HUMUS(kg/ha)(BIU)
                    sol_layer_pro[44] = sol_layer_pro[44] + "%8.2f\n" \
                        %(0.00)
            #  ! 46  FE26 = IRON CONTENT(%)
                    sol_layer_pro[45] = sol_layer_pro[45] + "%8.2f\n" \
                        %(0.00)
            #  ! 47  SULF = SULFUR CONTENT(%)                 
                    sol_layer_pro[46] = sol_layer_pro[46] + "%8.2f\n" \
                        %(0.00)
            #  ! 48  ASHZ = SOIL HORIZON(A,B,C)                                                                            
                    sol_layer_pro[47] = sol_layer_pro[47] + "%8s\n" \
                        %(" ")
            #   ! 49  CGO2 = O2 CONC IN GAS PHASE (g/m3 OF SOIL AIR)
                    sol_layer_pro[48] = sol_layer_pro[48] + "%8.2f\n" \
                        %(0.00)
            #   ! 50  CGCO2= CO2 CONC IN GAS PHASE (g/m3 OF SOIL AIR)                                                       
                    sol_layer_pro[49] = sol_layer_pro[49] + "%8.2f\n" \
                        %(0.00)
            #   ! 51  CGN2O= N2O CONC IN GAS PHASE (g/m3 OF SOIL AIR)                 
                    sol_layer_pro[50] = sol_layer_pro[50] + "%8.2f\n" \
                        %(0.00)

    for layproidx in range(3, 51):
        outf.writelines(sol_layer_pro[layproidx])
    outf.close()

def doSetup(hruinvar, idx, soldb):
    #[0latitude, 1longitude, 2soil, 3landuse, 4slope, 5dem, 6rowid_colid, 7bmpid]

    #exclude those soil as water
    soilname = " "
    selectdata = soldb.loc[soldb['mukey'] == int(hruinvar[2])]
    soldata = selectdata.to_dict('records')  
    soilname = soldata[0]["muname"]
    soldeparray = [soldata[0]["l1_layerdepth"],
                    soldata[0]["l2_layerdepth"],
                    soldata[0]["l3_layerdepth"],
                    soldata[0]["l4_layerdepth"],
                    soldata[0]["l5_layerdepth"],
                    soldata[0]["l6_layerdepth"],
                    soldata[0]["l7_layerdepth"],
                    soldata[0]["l8_layerdepth"],
                    soldata[0]["l9_layerdepth"],
                    soldata[0]["l10_layerdepth"]]
    soldeparray = map(float, soldeparray)

    if ((soilname == "Water") or (max(soldeparray) <0.02)):

        return()
    else:
        # Change directory to run directory and create current run directories.
        os.chdir(workdir + "\\MPRUNS\\everyhru_map")
        try:
            if not os.path.exists(str(idx)):
                os.makedirs(str(idx))
        # There are no exceptions.
        except:
            pass

        currentdir = workdir + "\\MPRUNS\\everyhru_map\\" + str(idx)
        # Attempt to copy inputs to current run directory.
        try:
            copyfile(workdir+"\\REQUIRED\\APEXFILE.DAT", currentdir + "\\APEXFILE.DAT")
            copyfile(workdir+"\\REQUIRED\\APEXCONT.DAT", currentdir + "\\APEXCONT.DAT")
            copyfile(workdir+"\\REQUIRED\\APEXDIM.DAT", currentdir + "\\APEXDIM.DAT")
            copyfile(workdir+"\\REQUIRED\\APEXRUN.DAT", currentdir + "\\APEXRUN.DAT")
            copyfile(workdir+"\\REQUIRED\\SOILCOM.DAT", currentdir + "\\SOILCOM.DAT")
            copyfile(workdir+"\\REQUIRED\\SITECOM.DAT", currentdir + "\\SITECOM.DAT")
            copyfile(workdir+"\\REQUIRED\\SUBACOM.DAT", currentdir + "\\SUBACOM.DAT")
            copyfile(workdir+"\\REQUIRED\\SOL.SOL", currentdir + "\\SOL.SOL")
            copyfile(workdir+"\\REQUIRED\\SIT.SIT", currentdir + "\\SIT.SIT")
            copyfile(workdir+"\\REQUIRED\\SUB.SUB", currentdir + "\\SUB.SUB")
            copyfile(workdir+"\\REQUIRED\\WINDWEPP.DAT", currentdir + "\\WINDWEPP.DAT")
            copyfile(workdir+"\\REQUIRED\\WPM1WEPP.DAT", currentdir + "\\WPM1WEPP.DAT")
            copyfile(workdir+"\\REQUIRED\\OPSCCOM_bmps.DAT", currentdir + "\\OPSCCOM_bmps.DAT")  
            copyfile(workdir+"\\REQUIRED\\OPSCCOM_ops.DAT", currentdir + "\\OPSCCOM_ops.DAT")                      

        # Exit upon failure to copy.
        except IOError as e:
            print("Unable to copy file. %s" % e)
            sys.exit()
            
        # Modify input files.
        modifySubFile(hruinvar, idx, soldb)
        modifySitFile(hruinvar, idx, soldb)
        modifySolFile(hruinvar, idx, soldb)

        # Modify APEX file location
        f = open("APEXFILE.DAT","r")
        ob = open("OPSCCOM_bmps.DAT","r")
        oo = open("OPSCCOM_ops.DAT","r")
        wi = open("WINDWEPP.DAT","r")
        wp = open("WPM1WEPP.DAT","r")

        fstr = f.read()
        obstr = ob.read()
        oostr = oo.read()
        wistr = wi.read()
        wpstr = wp.read()

        f.close()
        ob.close()
        oo.close()
        wi.close()
        wp.close()

        # replace the APEX files location with working directory
        fstr = fstr.replace("C:\\APEXMP\\REQUIRED\\", workdir + "\\REQUIRED\\")
        obstr = obstr.replace("C:\\APEXMP\\REQUIRED\\", workdir + "\\REQUIRED\\")
        oostr = oostr.replace("C:\\APEXMP\\REQUIRED\\", workdir + "\\REQUIRED\\")
        wistr = wistr.replace("C:\\APEXMP\\REQUIRED\\", workdir + "\\REQUIRED\\")
        wpstr = wpstr.replace("C:\\APEXMP\\REQUIRED\\", workdir + "\\REQUIRED\\")   
         
        # change opearation file name
        if (len(hruinvar) == 8):
            fstr = fstr.replace("OPSCCOM.DAT", "OPSCCOM_bmps.DAT")
        else:
            fstr = fstr.replace("OPSCCOM.DAT", "OPSCCOM_ops.DAT")   

        # Write the new files.
        outf = open("APEXFILE.DAT","w")
        outob = open("OPSCCOM_bmps.DAT","w")
        outoo = open("OPSCCOM_ops.DAT","w")
        outwi = open("WINDWEPP.DAT","w")
        outwp = open("WPM1WEPP.DAT","w")  
        outf.write(fstr)
        outoo.write(oostr)
        outob.write(obstr)
        outwi.write(wistr)
        outwp.write(wpstr)
        outf.close()
        outoo.close()
        outob.close()
        outwi.close()
        outwp.close() 

def doRun(idx, tsink):

    # Change to root run directory and create the results file.
    currentdir = workdir + "\\MPRUNS\\everyhru_map\\" + str(idx)
    os.chdir(currentdir)
        
    # Run the apex runs.
    runlog = open(currentdir + "\\runlog.txt", "wb")
    runerr = open(currentdir + "\\runerr.txt", "wb")

    apex = workdir + "\\apex1501.exe"
    subprocess.call(apex, stdout=runlog, stderr=runerr, shell=True)
    runlog.close()
    runerr.close()
		
    os.remove("Results.MSA")	
    os.remove("Results.MWS")	
    os.remove("Results.OUT")	
    os.remove("Results.AWP")    	
    os.remove("APEXCONT.DAT")	
    os.remove("APEXDIM.DAT")	
    os.remove("APEXFILE.DAT")	
    os.remove("APEXRUN.DAT")	
    os.remove("SITECOM.DAT") 	
    os.remove("SOILCOM.DAT")	
    os.remove("SUBACOM.DAT")
    os.remove("OPSCCOM_bmps.DAT")
    os.remove("OPSCCOM_ops.DAT")
    os.remove("WINDWEPP.DAT")
    os.remove("WPM1WEPP.DAT")
    os.remove("SOL.SOL")
    os.remove("SUB.SUB")
    os.remove("SIT.SIT") 	
    os.remove("runerr.txt")	
    os.remove("runlog.txt")
    for filename in glob.glob("./fort*"):
        os.remove(filename) 
   
    # Print progress to terminal.
    if (float(idx) % 25 == 0):
        now = datetime.datetime.now()
        telap = now - tsink
        hrelap = int(telap.total_seconds() // 3600)
        mtelap = int((telap.total_seconds() - hrelap*3600) // 60)
        scelap = int((telap.total_seconds() - hrelap*3600 - mtelap*60) // 1)
        print("Run #%s Completed.    Elasped Time (HH:MM:SS): %02d:%02d:%02d" % (idx, hrelap, mtelap, scelap))
        sys.stdout.flush()

def parseoutputs(idx):

    # Change to root run directory and create the results file.
    os.chdir(workdir)
    currentdir = workdir + "\\MPRUNS\\everyhru_map\\" + str(idx)

    # Set default values for missing results.
    precip = -999
    runoff = -999
    soilloss = -999
    TN = -999
    TP = -999
    
    # Populate results from .wss file.
    if (os.path.exists(currentdir + "\\Results.WSS") is True) and (os.path.getsize(currentdir + "\\Results.WSS") != 0):
        wss = open(currentdir + "\\Results.WSS", "r")
        wssout = wss.readlines()
        wsslastline = wssout[-1].split()
        wssprcpline = wssout[-24].split()
        if ('*' not in wsslastline) and ('*' not in wssprcpline):
            precip = str(wssprcpline[13])
            runoff = str(wsslastline[5])
            soilloss = wsslastline[-13]
            TN = str(round(float(wsslastline[-8])+float(wsslastline[-7])+float(wsslastline[-4])+float(wsslastline[-3])+float(wsslastline[-2])+float(wsslastline[-1]),2))
            TP = str(round(float(wsslastline[-5]) + float(wsslastline[-6]),2))
        wss.close()

    # Return populated results.
    return [precip, runoff, soilloss, TN, TP]

def main():
    
    # Change to working directory.
    os.chdir(workdir)

    # Get the current datetime and create the run result file.
    now = datetime.datetime.now()
    tstart = str(now.year) + "-" + str(now.month) + "-" + str(now.day) + "-" + str(now.hour) + "-" + str(now.minute) + "-" + str(now.second)
    tsink = now

    # This part can be change to user selection input with the apexmp wrapper
    # Create empty lists of inputs.
    ops_or_bmps = ''
    bmps = ''


    # Create the run and result folder
    try:
        if not os.path.exists("MPRUNS\\everyhru_map"):
            os.makedirs("MPRUNS\\everyhru_map")
        if not os.path.exists("RESULTS\\everyhru_map"):
            os.makedirs("RESULTS\\everyhru_map")
    except:
        pass

    xout = open(workdir + "\\RESULTS\\everyhru_map\\" + tstart + ".csv","w")
    xout.write("RunID,Soil,Landuse,Slope(%),Latitude,Longitude,Elevation(m),Operation,RowID_ColumnID,Precipitation(mm/yr),Runoff(mm/yr),Soil Loss(t/ha),Total N(kg/ha),Total P(kg/ha)\n")
    xout.close()

    # Combine inputs for the job list.
    th1 = datetime.datetime.now()
    print("\nList prepartion of has begun at " + str(th1) + " ...\n\r")

    # Reset the run counter to 1.
    idx = 0
    hruinvar = []

    # Create the multiprocessing job list.
    hrulsts = ctyData()      

    # determine ops or bmps, and reorganize job list
    for hruidx in range(len(list(hrulsts.keys()))): 
        if ubmp == str(0):
            # Get inputs.
            hruinpart1 = []
            hruinpart2 = []
            hruinvarlst = []
            hruinpart2 = [list(hrulsts.keys())[hruidx]]
            hruinpart1 = hrulsts[list(hrulsts.keys())[hruidx]]
            hruinvarlst = hruinpart1 + hruinpart2
            hruinvar.append(hruinvarlst)
            idx = idx + 1
        else:
            for bmpid in range(int(bmps[0])):
                # Get inputs.
                hruinpart1 = []
                hruinpart2 = []
                bmplst = []
                hruinvarlst = []
                hruinpart2 = [list(hrulsts.keys())[hruidx]]
                hruinpart1 = hrulsts[list(hrulsts.keys())[hruidx]]
                bmplst = [str(bmpid + 1)]
                hruinvarlst = hruinpart1 + hruinpart2 + bmplst
                hruinvar.append(hruinvarlst)
                idx = idx + 1

    th2 = datetime.datetime.now()
    print("\nList prepartion has completed at " + str(th2) + " .\n\r")

    # Prepare soildatabase for setup
    
    #[0latitude, 1longitude, 2soil, 3landuse, 4slope, 5dem, 6rowid_colid, 7bmpid]
    soildatabase = pd.read_csv(workdir+"\\INPUTS\\ssurgo2apex.csv")
    mukeys = []
    for i in range(len(hruinvar)):
        hru = hruinvar[i]
        mukeys.append(hru[2])
    rows = soildatabase.mukey.isin(mukeys)
    soildb = soildatabase[rows]

    # Return to the root working directory.
    os.chdir(workdir)

    # Create run job pool.
    s_list = []
    r_list = []
    for i in range(len(hruinvar)):
        s_list.append((hruinvar[i], i, soildb))
        r_list.append((i, tsink))

    # Clear the terminal output.
    print("\n" * 30)

    # Create the worker pool to setup for model runs.
    tps1 = datetime.datetime.now()
    print("\nParallel setup of " + str(idx) + " runs has begun at " + str(tps1) + " ...\n\r")
    sys.stdout.flush()
    workers = Pool(nworkers)
    for i in range(len(s_list)):
        workers.apply_async(doSetup, args=s_list[i])
    workers.close()
    workers.join()
    tps2 = datetime.datetime.now()    
    print("\nParallel setup has completed at " + str(tps2) + " .\n\r")

    # Create the worker pool to execute model runs.
    tpr1 = datetime.datetime.now()
    print("\nParallel execution of " + str(idx) + " runs has begun at " + str(tpr1) + " ...\n\r")
    sys.stdout.flush()
    workers = Pool(nworkers)
    for i in range(len(r_list)):
        workers.apply_async(doRun, args=r_list[i])
        sys.stdout.flush()
    workers.close()
    workers.join()
    tpr2 = datetime.datetime.now()
    print("\nParallel execution has completed at " + str(tpr2) + " .\n\r")

    # Open results file.
    tg1 = datetime.datetime.now()
    print("\nGathering results has begun at " + str(tg1) + " ...\n\r")
    sys.stdout.flush()
    xout = open(workdir + "\\RESULTS\\everyhru_map\\" + tstart + ".csv", "a")

    # Read results from runs and store.
    for i in range(len(hruinvar)):

        #[0latitude, 1longitude, 2soil, 3landuse, 4slope, 5dem, 6rowid_colid, 7bmpid]
        # Get run parameters.

        soil = str(hruinvar[i][2])
        landuse = str(hruinvar[i][3])
        slope = str(hruinvar[i][4]*100)
        latitude = str(float(hruinvar[i][0]))
        longitude = str(float(hruinvar[i][1]))
        elevation = str(hruinvar[i][5])
        rowid_colid = str(hruinvar[i][6])
        if ubmp == str(0):
            operation = str(1)
        else:
            operation = str(hruinvar[i][7])

        # Parse outputs.
        res = parseoutputs(i)
        outstr = (str(i) + "," + soil  + "," + landuse + "," + slope + "," + latitude + "," + longitude + "," + elevation
                 + ","  + operation + ","+ rowid_colid + "," + str(res[0]) + ","+ str(res[1]) + ","+ str(res[2]) + ","+ str(res[3]) + ","+ str(res[4]) + "\n")

        # Write results to file.
        xout.write(outstr)
    
    # Close results file.
    xout.close()
    tg2 = datetime.datetime.now()
    print("Gathering has completed at " + str(tg2) + " .\n\r")

    # Get the end time.
    now = datetime.datetime.now()
    tend = str(now.year) + "-" + str(now.month) + "-" + str(now.day) + "-" + str(now.hour) + "-" + str(now.minute) + "-" + str(now.second)

    # Print the start and end times.
    print("\nStart time: " + tstart)
    print("\nEnd time: " + tend)

    # Exit upon completion.
    sys.exit()


#############################################################################
################################ RUN PROGRAM ################################
#############################################################################

if __name__ == '__main__':
    main()
