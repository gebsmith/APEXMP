# -*- coding: utf-8 -*-
#############################################################################
############################## PROGRAM METADATA #############################
#############################################################################

#  Last Updated by: Feng Pan
#  Last Updated on: 8 Oct 2020
#  Purpose: This program is designed to run combinations of APEX input files.
#           This script is designed to run in parallel to execute large
#           batches of runs quickly.
#
#  Contributors: Qingyu Feng (provided APEX series run code which was heavily 
#               modified from his original script) and Ryan P. McGehee (
#               helped to modify multiprocessing routines and debug). Feng 
#               made most modification contributions and refactored the final
#               code.

#############################################################################
############################# INSTRUCTIONS TO RUN ###########################
#############################################################################

# Requirements: Place call_apex_mp_(version).py in the working directory. 
#               Requires pandas module (in python 3.x version). THE ROOT 
#               DIRECTORY PATH MUST NOT CONTAIN ANY SPACES. In this directory
#               the following must also be present:
#
# Files or directory:    
#           apex1501.exe                (the version of APEX you want to run)
#           REQUIRED directory          (the files needed to run and no-need 
#                                       to modify, provided in this package)
#           INPUTS directory            (directories of county, dem, lanuse, 
#                                       slope, soil, and zipcode; soil-database
#                                       file, zipcode-database file)
#           MPRUNS                      (will be generated by the code to storage
#                                       results of each apex run)
#           RESULTS                     (will be generated by the code to storage
#                                       the output file of the entire code run)
#
# Disk Space: At least 4 MB of space per run is required for keeping all run
#             outputs. The requirement is much smaller if one does not need to 
#             preserve the monthly, average monthly, average annualand output files. 
#             This code can be modified to remove those files after each run in 
#             order to increase run limits.


##############################################################################
############################## IMPORT LIBRARIES ##############################
##############################################################################

import datetime
import math
import os, re
import shutil
import signal
import string
import subprocess
import sys
import glob
import pandas as pd
import xml.etree.ElementTree as ET

from datetime import timedelta
from multiprocessing import cpu_count, Pool, Process
from shutil import copyfile
from subprocess import Popen,PIPE

#############################################################################
############################## GLOBAL VARIABLES #############################
#############################################################################

workdir = sys.argv[1]
delete = sys.argv[2]
verb = sys.argv[3]
ubmp = sys.argv[4]
bmps = sys.argv[5]
devm = sys.argv[6]
nworkers = sys.argv[7]


#############################################################################
############################## DEFINE FUNCTIONS #############################
#############################################################################

def readAsc(filename):
    
    #This function read the asc files into dataframe

    try:
        fid = open(filename, "r")
    except:
        print("File %s does not exist!!!" %(filename))
    
    header = []
    tmpline = []
    
    #read the metadata: 
    # [0]ncols, [1]nrows, [2]xllcorner, [3]yllcorner, [-2]cellsize, [-1]NODATA_value 0
    # (for decimal projection, there could be tiny different size of x and y,
    #  so there could be xcellsize and ycellsize which takes two rows)

    for i in range (7):
        tmpline = fid.readline()
        tmpline = tmpline.split(" ")
        while "" in tmpline:
            tmpline.remove("")
        if (len(tmpline) == 2):      
            tmpline[-1] = tmpline[-1][:-1]    
            header.append(tmpline)
    
    nodata = header[-1][1]

    #read the data    
    tmpline2 = ""
    data = []
    for j in range (int(header[1][1])):
        tmpline2 = fid.readline()  
        tmpline2 = tmpline2.split(" ")
        while "" in tmpline2:
            tmpline2.remove("")
        if (len(tmpline2) > 2):
            tmpline2[-1] = tmpline2[-1][:-1]
        data.append(tmpline2)
    
    fid.close()

    return nodata, data

def createHrus(stctyziplst,
                stctylst,
                slopearray,
                landusearray,
                soilarray,
                ziparray,
                demarray,
                slpnodata,
                lunodata,
                solnodata,
                zipnodata,
                demnodata):

    # This is a loop through all arrays.
    # An array will be created to store all
    # of the hru inputs. If the old one is
    # in the list, update the area and add 
    # up the dem, slope, longitude, latitude. 
    # If not append one and get area as one.
    # An hru here will have 0state, 1county, 
    # 2zipcode, 3soil, 4landuse, 5slopegroup,
    # 6hru count, 7slope, 8lat, 9lon, and 10dem. 

    hrulist = {}
    
    # avoid the boundary
    for rowidx in range(len(landusearray)-2):
        for colidx in range(len(landusearray[rowidx])-2):
            
            # eliminate some cells with error values
            if ((slopearray[rowidx][colidx] != "-1.#QNAN")
                and (slopearray[rowidx][colidx] != "1.#QNAN")):  
                
                # get the state-county-zipcode combination
                stkey = "_".join([stctylst,
                                ziparray[rowidx][colidx]])      

                # regroup the hrus by slope range
                slope = 0
                if (float(slopearray[rowidx][colidx])<=0.02):
                    slope = 2
                elif ((float(slopearray[rowidx][colidx])>0.02) and (float(slopearray[rowidx][colidx])<=0.05)):
                    slope = 5
                elif (float(slopearray[rowidx][colidx])>0.05):
                    slope = 10            

                temphru1 = []
                # If not no-data cells and state-county-zipcode combination exists, create the hrulist
                if ((ziparray[rowidx][colidx] != zipnodata)
                    and (soilarray[rowidx][colidx] != solnodata)
                    and (landusearray[rowidx][colidx] != lunodata)
                    and (slopearray[rowidx][colidx] != slpnodata)
                    and (demarray[rowidx][colidx] != demnodata)
                    and (stkey in stctyziplst)):

                    # [0state, 1county, 2zipcode, 3soilmky, 4landuse, 5slopegroup]
                    temphru1 = [stctylst.split("_")[0], 
                                stctylst.split("_")[1],
                                ziparray[rowidx][colidx],
                                soilarray[rowidx][colidx],
                                landusearray[rowidx][colidx],
                                str(slope)]                              
                    temphru1 = "_".join(temphru1)

                    # [6hru count, 7slope, 8latitude, 9longitude, 10dem, 11rowid_colid]
                    if not temphru1 in hrulist:                        
                        hrulist[temphru1] = [1, 
                                            abs(float(slopearray[rowidx][colidx])),
                                            stctyziplst[stkey][-1][:-1],
                                            stctyziplst[stkey][-2],
                                            abs(float(demarray[rowidx][colidx])),
                                            (str(rowidx)+"_"+str(colidx))]

                    else:
                        # add up the hru count
                        hrulist[temphru1][0] = hrulist[temphru1][0] + 1
                        # Calculate sum of slope, dem
                        hrulist[temphru1][1] = (hrulist[temphru1][1] + abs(float(slopearray[rowidx][colidx])))
                        hrulist[temphru1][-2] = (hrulist[temphru1][-2] + abs(float(demarray[rowidx][colidx]))) 
                        hrulist[temphru1][-1] = (hrulist[temphru1][-1] +";"+ (str(rowidx)+"_"+str(colidx)))
    
    return hrulist

def ctyData(stctyziplst, stctylst):

    ctyname = stctylst
    # Read slope
    fnslpasc = os.path.join(workdir + "\\INPUTS\\slope\\asc",	
                                    "slp%s.asc" %(ctyname))	                                   	
    slpnodata, slopearray = readAsc(fnslpasc)	
    	
    # Read land use	
    fnluasc = os.path.join(workdir + "\\INPUTS\\landuse\\asc",	
                                    "lu%s.asc" %(ctyname))	                                   	
    lunodata, landusearray = readAsc(fnluasc)	
    	
    # Read Soil	
    fnsolasc = os.path.join(workdir + "\\INPUTS\\soil\\asc",	
                                    "sol%s.asc" %(ctyname))	                                   	
    solnodata, soilarray = readAsc(fnsolasc)	
    	
    # Read zip	
    fnzipasc = os.path.join(workdir + "\\INPUTS\\zipcode\\asc",	
                                    "zip%s.asc" %(ctyname))	                                  	
    zipnodata, ziparray = readAsc(fnzipasc)	
    	
    # Read dem	
    fndemasc = os.path.join(workdir + "\\INPUTS\\dem\\asc",	
                                    "dem%s.asc" %(ctyname))	                                 	
    demnodata, demarray = readAsc(fndemasc)

    # After reading the raster files into the arrays, the next step 
    # is to overlap them.
    hrulsts = createHrus(stctyziplst,
                            ctyname,
                            slopearray,
                            landusearray,
                            soilarray,
                            ziparray,
                            demarray,
                            slpnodata,
                            lunodata,
                            solnodata,
                            zipnodata,
                            demnodata)

    return hrulsts

def getUplandManningN(landuse):
        
        # There are 9 values for land use, and their corresponding
        # manning's n will be assigned as:
        # 1. corn: 0.13
        # 2. soybean: 0.13
        # 3. Wheat: 0.13
        # 4. Hay: 0.15
        # 5. Pasture: 0.15
        # 6. Urban: 0.01
        # 7. Forest: 0.41
        # 8. Water: 0.01
        # 9. Other agriculture: 0.13
        manningn = 0
        
        if (landuse in [1, 2, 3, 9]):
            manningn = 0.13
        elif (landuse in [4, 5]):
            manningn = 0.15
        elif (landuse in [6, 8]):
            manningn = 0.01
        elif (landuse == 7):
            manningn = 0.41
        else:
            manningn = 0.15
            
        return manningn

def modifySubFile(hruinvar, idx, soldb, statename):

    # Change to current run directory and read .sub file.
    os.chdir(workdir + ("\\MPRUNS\\grouphru_map\\%s\\" %(statename)) + str(idx))

    # hruinvar = [0state, 1county, 2zipcode, 3soilmky,
    # 4landuse, 5slopegroupe, 6cellcount, 7avgslp, 8lat, 9long, 10dem, 11rowid_colid, 12bmpid]

    selectdata = soldb.loc[soldb['mukey'] == int(hruinvar[3])]
    soldata = selectdata.to_dict('records')

    hsgnumb = 0
    hsgnumb = hsgLetter2Num(soldata[0]["hydgrpdcd"])

    f = open("SUB.SUB","r")
    fstr = f.read()
    f.close()

    # Modify the sub file with new values.
    if (len(hruinvar) == 13):
        fstr = fstr.replace("__opsid__",str(int(hruinvar[12])))
    else:
        fstr = fstr.replace("__opsid__",str(int(hruinvar[4])))
    fstr = fstr.replace("__latitude__",str(round(float(hruinvar[8]),7)))
    fstr = fstr.replace("__longitude__",str(round(float(hruinvar[9]),7)))
    fstr = fstr.replace("__wsa_ha__",str(round((int(hruinvar[6]))*900/10000,3)))
    fstr = fstr.replace("__chl__",str(round(float(soldata[0]["slopelenusle_r"]),3))) 
    fstr = fstr.replace("__chs__",str(round(float(hruinvar[7])/int(hruinvar[6]),3)))
    fstr = fstr.replace("__slp__",str(round(float(hruinvar[7])/int(hruinvar[6]),3)))  
    fstr = fstr.replace("__splg__",str(round(float(soldata[0]["slopelenusle_r"]),3)))      
    fstr = fstr.replace("__upn__",str(round(float(getUplandManningN(hruinvar[4])),3))) 
    fstr = fstr.replace("__rchl__",str(round(float(soldata[0]["slopelenusle_r"]),3)))  
    fstr = fstr.replace("__rchs__",str(round(float(hruinvar[7])/int(hruinvar[6]),3))) 

    if (hsgnumb == 3 or hsgnumb == 4 and hruinvar[7] < 0.02):
        fstr = fstr.replace("__ddi__",str(1000.0))
        fstr = fstr.replace("__dde__",str(3))
    else:
        fstr = fstr.replace("__ddi__",str(0.00))
        fstr = fstr.replace("__dde__",str(0.00))
 
    # Write the new sub file.
    outf = open("SUB.SUB","w")
    outf.write(fstr)
    outf.close()

def modifySitFile(hruinvar, idx, soldb, statename):
    
    # Change to current run directory and read .sit file.
    os.chdir(workdir + ("\\MPRUNS\\grouphru_map\\%s\\" %(statename)) + str(idx))

    # hruinvar = [0state, 1county, 2zipcode, 3soilmky,
    # 4landuse, 5slopegroupe, 6cellcount, 7avgslp, 8lat, 9long, 10dem, 11rowid_colid, 12bmpid]

    selectdata = soldb.loc[soldb['mukey'] == int(hruinvar[3])]
    soldata = selectdata.to_dict('records')

    f = open("SIT.SIT","r")
    fstr = f.read()
    f.close()

    # Modify the sit file with new values.
    fstr = fstr.replace("__latitude__",str(round(float(hruinvar[8]),2)))
    fstr = fstr.replace("__longitude__",str(round(float(hruinvar[9]),2)))
    fstr = fstr.replace("__elev__",str(round(float(hruinvar[10])/int(hruinvar[6]),2)))
    fstr = fstr.replace("__bchl__",str(round(float(soldata[0]["slopelenusle_r"]),2)))  
    fstr = fstr.replace("__bchs__",str(round(float(hruinvar[7])/int(hruinvar[6]),2)))  

    # Write the new sit file.
    outf = open("SIT.SIT","w")
    outf.write(fstr)
    outf.close()

def hsgLetter2Num(letter):
    
    if "/" in letter:
        letter = letter.split("/")[0]
        
    if letter == "A":
        numb = 1
    elif letter == "B":
        numb = 2
    elif letter == "C":
        numb = 3
    else:
        numb = 4
        
    return numb

def modifySolFile(hruinvar, idx, soldb, statename):

    # Change to current run directory and read .sol file.     
    os.chdir(workdir + ("\\MPRUNS\\grouphru_map\\%s\\" %(statename)) + str(idx))

    # hruinvar = [0state, 1county, 2zipcode, 3soilmky,
    # 4landuse, 5slopegroupe, 6cellcount, 7avgslp, 8lat, 9long, 10dem, 11rowid_colid, 12bmpid]

    selectdata = soldb.loc[soldb['mukey'] == int(hruinvar[3])]
    soldata = selectdata.to_dict('records')

    # Modify the first two lines of sol file with new values.
    
    # Update line 1: desctiption
    # Update line 2
    hsgnumb = 0
    hsgnumb = hsgLetter2Num(soldata[0]["hydgrpdcd"])
    # No need to update Line 3:  Same format as line 2, different parameters. 
    # Some values were set to prevent any potential model run failure.
    # the 5th variable ZQT, should be from 0.01 to 0.25.
    # the 6th and 7th variable ZF should be from 0.05 to 0.25
    # the 8 and 9 should be larger than 0.03 and 0.3
    # The 10th should be left blank
    outf = open("SOL.SOL","w")
    fstr1 = "%20s\n" %(soldata[0]["muname"])
    outf.writelines(fstr1)
    fstr2 = "%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f\n"\
                        %(float(soldata[0]["albedodry_r"]),\
                          float(hsgnumb), 0.00,\
                          float(soldata[0]["wtdepannmin"]),\
                          0.00, 0.00, 0.00, 0.00, 0.00, 0.00)
    outf.writelines(fstr2)
    fstr3 = "%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f        \n"\
                    %(10.00, 
                        0.00,
                        50.00,
                        2.00,
                        0.01,
                        0.05,
                        0.05,
                        0.03,
                        0.30
                        )
    outf.writelines(fstr3)
    # Writing line 4 to 51 of sol file with new values
    # Starting from line 4, the variables will be writen for 
    # properties for eacy layer, and each column represent one layer.
    # It is better to use a loop to do the writing.

    sol_layer_pro = [""]*52
    layeridxlst = []
    layeridxlst = [int(float(soldata[0]["l1_layerid"])),
                    int(float(soldata[0]["l2_layerid"])),
                    int(float(soldata[0]["l3_layerid"])),
                    int(float(soldata[0]["l4_layerid"])),
                    int(float(soldata[0]["l5_layerid"])),
                    int(float(soldata[0]["l6_layerid"])),
                    int(float(soldata[0]["l7_layerid"])),
                    int(float(soldata[0]["l8_layerid"])),
                    int(float(soldata[0]["l9_layerid"])),
                    int(float(soldata[0]["l10_layerid"]))
                ]
    extra = {}
    extra = {"l1_cnds":float(5.00),
            "l2_cnds":float(2.50),
            "l3_cnds":float(2.50),
            "l4_cnds":float(0.00),
            "l5_cnds":float(0.00),
            "l6_cnds":float(0.00),
            "l7_cnds":float(0.00),
            "l8_cnds":float(0.00),
            "l9_cnds":float(0.00),
            "l10_cnds":float(0.00)
            }   
    
    for layeridx in range(0, max(layeridxlst)):
        if layeridx < max(layeridxlst)-1:
            #  !  4  Z    = DEPTH TO BOTTOM OF LAYERS(m)            
                    sol_layer_pro[3] = sol_layer_pro[3] + "%8.2f" \
                        %(float(soldata[0]["l%i_layerdepth" %(layeridx+1)])/100)
            #  !  5  BD   = BULK DENSITY(t/m3)                
                    sol_layer_pro[4] = sol_layer_pro[4] + "%8.2f" \
                        %(float(soldata[0]["l%i_bulkdensity" %(layeridx+1)]))
            #  !  6  UW   = SOIL WATER CONTENT AT WILTING POINT(1500 KPA)(m/m)                                             
            #  !            (BLANK IF UNKNOWN)                
                    sol_layer_pro[5] = sol_layer_pro[5] + "%8.2f" \
                        %(float(soldata[0]["l%i_wiltingpoint" %(layeridx+1)])/100)
            #  !  7  FC   = WATER CONTENT AT FIELD CAPACITY(33KPA)(m/m)                                                    
            #  !            (BLANK IF UNKNOWN)                
                    sol_layer_pro[6] = sol_layer_pro[6] + "%8.2f" \
                        %(float(soldata[0]["l%i_fieldcapacity" %(layeridx+1)])/100)
            #  !  8  SAN  = % SAND                 
                    sol_layer_pro[7] = sol_layer_pro[7] + "%8.2f" \
                        %(float(soldata[0]["l%i_sandtotal" %(layeridx+1)]))
            #  !  9  SIL  = % SILT                
                    sol_layer_pro[8] = sol_layer_pro[8] + "%8.2f" \
                        %(float(soldata[0]["l%i_silttotal" %(layeridx+1)]))
            #  ! 10  WN   = INITIAL ORGANIC N CONC(g/t)       (BLANK IF UNKNOWN)                
                    sol_layer_pro[9] = sol_layer_pro[9] + "%8.2f" \
                        %(0.00)
            #  ! 11  PH   = SOIL PH                
                    sol_layer_pro[10] = sol_layer_pro[10] + "%8.2f" \
                        %(float(soldata[0]["l%i_ph" %(layeridx+1)]))
            #  ! 12  SMB  = SUM OF BASES(cmol/kg)              (BLANK IF UNKNOWN)
                    sol_layer_pro[11] = sol_layer_pro[11] + "%8.2f" \
                        %(float(soldata[0]["l%i_sumofbases" %(layeridx+1)]))
            #  ! 13  WOC  = ORGANIC CARBON CONC(%)                
                    sol_layer_pro[12] = sol_layer_pro[12] + "%8.2f" \
                        %(float(soldata[0]["l%i_organicmatter" %(layeridx+1)]))
            #  ! 14  CAC  = CALCIUM CARBONATE(%)                 
                    sol_layer_pro[13] = sol_layer_pro[13] + "%8.2f" \
                        %(float(soldata[0]["l%i_caco3" %(layeridx+1)]))
            #  ! 15  CEC  = CATION EXCHANGE CAPACITY(cmol/kg)(BLANK IF UNKNOWN                
                    sol_layer_pro[14] = sol_layer_pro[14] + "%8.2f" \
                        %(float(soldata[0]["l%i_cec" %(layeridx+1)]))
            #  ! 16  ROK  = COARSE FRAGMENTS(% VOL)              (BLANK IF UNKNOWN)           
                    sol_layer_pro[15] = sol_layer_pro[15] + "%8.2f" \
                        %(100-float(soldata[0]["l%i_croasefragment" %(layeridx+1)]))
            #  ! 17  CNDS = INITIAL SOL N CONC(g/t)            (BLANK IF UNKNOWN) 
                    sol_layer_pro[16] = sol_layer_pro[16] + "%8.2f" \
                        %(float(extra["l%i_cnds" %(layeridx+1)]))
            #  ! 18  SSF  = INITIAL SOL P CONC(g/t)       (BLANK IF UNKNOWN)
                    sol_layer_pro[17] = sol_layer_pro[17] + "%8.2f" \
                        %(float(soldata[0]["l%i_ph2osoluble_r" %(layeridx+1)]))
            #  ! 19  RSD  = CROP RESIDUE(t/ha)                (BLANK IF UNKNOWN)   
                    sol_layer_pro[18] = sol_layer_pro[18] + "%8.2f" \
                        %(0.00)
            #  ! 20  BDD  = BULK DENSITY(OVEN DRY)(t/m3)   (BLANK IF UNKNOWN)                
                    sol_layer_pro[19] = sol_layer_pro[19] + "%8.2f" \
                        %(float(soldata[0]["l%i_drybulkdensity" %(layeridx+1)]))
            #  ! 21  PSP  = P SORPTION RATIO                   (BLANK IF UNKNOWN)                  
                    sol_layer_pro[20] = sol_layer_pro[20] + "%8.2f" \
                        %(0.00) 
            #  ! 22  SATC = SATURATED CONDUCTIVITY(mm/h)     (BLANK IF UNKNOWN)
                    sol_layer_pro[21] = sol_layer_pro[21] + "%8.2f" \
                        %(float(soldata[0]["l%i_ksat" %(layeridx+1)]))
            #  ! 23  HCL  = LATERAL HYDRAULIC CONDUCTIVITY(mm/h)                
                    sol_layer_pro[22] = sol_layer_pro[22] + "%8.2f" \
                        %(0.00)
            #  ! 24  WPO  = INITIAL ORGANIC P CONC(g/t)      (BLANK IF UNKNOWN)                
                    sol_layer_pro[23] = sol_layer_pro[23] + "%8.2f" \
                        %(float(soldata[0]["l%i_ptotal" %(layeridx+1)])-float(soldata[0]["l%i_ph2osoluble_r" %(layeridx+1)]))
            #  ! 25  DHN  = EXCHANGEABLE K CONC (g/t)                
                    sol_layer_pro[24] = sol_layer_pro[24] + "%8.2f" \
                        %(0.00)
            #  ! 26  ECND = ELECTRICAL COND (mmho/cm)                
                    sol_layer_pro[25] = sol_layer_pro[25] + "%8.2f" \
                        %(float(soldata[0]["l%i_ec" %(layeridx+1)]))
            #  ! 27  STFR = FRACTION OF STORAGE INTERACTING WITH NO3 LEACHING                                              
            #  !                                               (BLANK IF UNKNOWN)                
                    sol_layer_pro[26] = sol_layer_pro[26] + "%8.2f" \
                        %(0.00)
            #  ! 28  SWST = INITIAL SOIL WATER STORAGE (m/m)                
                    sol_layer_pro[27] = sol_layer_pro[27] + "%8.2f" \
                        %(0.00)
            #  ! 29  CPRV = FRACTION INFLOW PARTITIONED TO VERTICLE CRACK OR PIPE FLOW                
                    sol_layer_pro[28] = sol_layer_pro[28] + "%8.2f" \
                        %(0.00)
            #  ! 30  CPRH = FRACTION INFLOW PARTITIONED TO HORIZONTAL CRACK OR PIPE                                        
            #  !            FLOW                 
                    sol_layer_pro[29] = sol_layer_pro[29] + "%8.2f" \
                        %(0.00)
            #  ! 31  WLS  = STRUCTURAL LITTER(kg/ha)           (BLANK IF UNKNOWN)                
                    sol_layer_pro[30] = sol_layer_pro[30] + "%8.2f" \
                        %(0.00)
            #  ! 32  WLM  = METABOLIC LITTER(kg/ha)            (BLANK IF UNKNOWN)            
                    sol_layer_pro[31] = sol_layer_pro[31] + "%8.2f" \
                        %(0.00)
            #  ! 33  WLSL = LIGNIN CONTENT OF STRUCTURAL LITTER(kg/ha)(B I U)                
                    sol_layer_pro[32] = sol_layer_pro[32] + "%8.2f" \
                        %(0.00)
            #  ! 34  WLSC = CARBON CONTENT OF STRUCTURAL LITTER(kg/ha)(B I U) 
                    sol_layer_pro[33] = sol_layer_pro[33] + "%8.2f" \
                        %(0.00)
            #  ! 35  WLMC = C CONTENT OF METABOLIC LITTER(kg/ha)(B I U)
                    sol_layer_pro[34] = sol_layer_pro[34] + "%8.2f" \
                        %(0.00)
            #  ! 36  WLSLC= C CONTENT OF LIGNIN OF STRUCTURAL LITTER(kg/ha)(B I U)
                    sol_layer_pro[35] = sol_layer_pro[35] + "%8.2f" \
                        %(0.00)
            #  ! 37  WLSLNC=N CONTENT OF LIGNIN OF STRUCTURAL LITTER(kg/ha)(BIU)
                    sol_layer_pro[36] = sol_layer_pro[36] + "%8.2f" \
                        %(0.00)
            #  ! 38  WBMC = C CONTENT OF BIOMASS(kg/ha)(BIU)
                    sol_layer_pro[37] = sol_layer_pro[37] + "%8.2f" \
                        %(0.00)
            #  ! 39  WHSC = C CONTENT OF SLOW HUMUS(kg/ha)(BIU)
                    sol_layer_pro[38] = sol_layer_pro[38] + "%8.2f" \
                        %(0.00)
            #  ! 40  WHPC = C CONTENT OF PASSIVE HUMUS(kg/ha)(BIU)
                    sol_layer_pro[39] = sol_layer_pro[39] + "%8.2f" \
                        %(0.00)
            #  ! 41  WLSN = N CONTENT OF STRUCTURAL LITTER(kg/ha)(BIU)
                    sol_layer_pro[40] = sol_layer_pro[40] + "%8.2f" \
                        %(0.00)
            #  ! 42  WLMN = N CONTENT OF METABOLIC LITTER(kg/ha)(BIU)
                    sol_layer_pro[41] = sol_layer_pro[41] + "%8.2f" \
                        %(0.00)
            #  ! 43  WBMN = N CONTENT OF BIOMASS(kg/ha)(BIU)
                    sol_layer_pro[42] = sol_layer_pro[42] + "%8.2f" \
                        %(0.00)
            #  ! 44  WHSN = N CONTENT OF SLOW HUMUS(kg/ha)(BIU)
                    sol_layer_pro[43] = sol_layer_pro[43] + "%8.2f" \
                        %(0.00)
            #  ! 45  WHPN = N CONTENT OF PASSIVE HUMUS(kg/ha)(BIU)
                    sol_layer_pro[44] = sol_layer_pro[44] + "%8.2f" \
                        %(0.00)
            #  ! 46  FE26 = IRON CONTENT(%)
                    sol_layer_pro[45] = sol_layer_pro[45] + "%8.2f" \
                        %(0.00)
            #  ! 47  SULF = SULFUR CONTENT(%)                 
                    sol_layer_pro[46] = sol_layer_pro[46] + "%8.2f" \
                        %(0.00)
            #  ! 48  ASHZ = SOIL HORIZON(A,B,C)                                                                            
                    sol_layer_pro[47] = sol_layer_pro[47] + "%8s" \
                        %(" ")
            #   ! 49  CGO2 = O2 CONC IN GAS PHASE (g/m3 OF SOIL AIR)
                    sol_layer_pro[48] = sol_layer_pro[48] + "%8.2f" \
                        %(0.00)
            #   ! 50  CGCO2= CO2 CONC IN GAS PHASE (g/m3 OF SOIL AIR)                                                       
                    sol_layer_pro[49] = sol_layer_pro[49] + "%8.2f" \
                        %(0.00)
            #   ! 51  CGN2O= N2O CONC IN GAS PHASE (g/m3 OF SOIL AIR)                 
                    sol_layer_pro[50] = sol_layer_pro[50] + "%8.2f" \
                        %(0.00)
        else:
           #  !  4  Z    = DEPTH TO BOTTOM OF LAYERS(m)            
                    sol_layer_pro[3] = sol_layer_pro[3] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_layerdepth" %(layeridx+1)])/100)
            #  !  5  BD   = BULK DENSITY(t/m3)                
                    sol_layer_pro[4] = sol_layer_pro[4] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_bulkdensity" %(layeridx+1)]))
            #  !  6  UW   = SOIL WATER CONTENT AT WILTING POINT(1500 KPA)(m/m)                                             
            #  !            (BLANK IF UNKNOWN)                
                    sol_layer_pro[5] = sol_layer_pro[5] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_wiltingpoint" %(layeridx+1)])/100)
            #  !  7  FC   = WATER CONTENT AT FIELD CAPACITY(33KPA)(m/m)                                                    
            #  !            (BLANK IF UNKNOWN)                
                    sol_layer_pro[6] = sol_layer_pro[6] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_fieldcapacity" %(layeridx+1)])/100)
            #  !  8  SAN  = % SAND                 
                    sol_layer_pro[7] = sol_layer_pro[7] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_sandtotal" %(layeridx+1)]))
            #  !  9  SIL  = % SILT                
                    sol_layer_pro[8] = sol_layer_pro[8] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_silttotal" %(layeridx+1)]))
            #  ! 10  WN   = INITIAL ORGANIC N CONC(g/t)       (BLANK IF UNKNOWN)                
                    sol_layer_pro[9] = sol_layer_pro[9] + "%8.2f\n" \
                        %(0.00)
            #  ! 11  PH   = SOIL PH                
                    sol_layer_pro[10] = sol_layer_pro[10] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_ph" %(layeridx+1)]))
            #  ! 12  SMB  = SUM OF BASES(cmol/kg)              (BLANK IF UNKNOWN)
                    sol_layer_pro[11] = sol_layer_pro[11] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_sumofbases" %(layeridx+1)]))
            #  ! 13  WOC  = ORGANIC CARBON CONC(%)                
                    sol_layer_pro[12] = sol_layer_pro[12] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_organicmatter" %(layeridx+1)]))
            #  ! 14  CAC  = CALCIUM CARBONATE(%)                 
                    sol_layer_pro[13] = sol_layer_pro[13] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_caco3" %(layeridx+1)]))
            #  ! 15  CEC  = CATION EXCHANGE CAPACITY(cmol/kg)(BLANK IF UNKNOWN                
                    sol_layer_pro[14] = sol_layer_pro[14] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_cec" %(layeridx+1)]))
            #  ! 16  ROK  = COARSE FRAGMENTS(% VOL)              (BLANK IF UNKNOWN)           
                    sol_layer_pro[15] = sol_layer_pro[15] + "%8.2f\n" \
                        %(100-float(soldata[0]["l%i_croasefragment" %(layeridx+1)]))
            #  ! 17  CNDS = INITIAL SOL N CONC(g/t)            (BLANK IF UNKNOWN) 
                    sol_layer_pro[16] = sol_layer_pro[16] + "%8.2f\n" \
                        %(float(extra["l%i_cnds" %(layeridx+1)]))
            #  ! 18  SSF  = INITIAL SOL P CONC(g/t)       (BLANK IF UNKNOWN)
                    sol_layer_pro[17] = sol_layer_pro[17] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_ph2osoluble_r" %(layeridx+1)]))
            #  ! 19  RSD  = CROP RESIDUE(t/ha)                (BLANK IF UNKNOWN)   
                    sol_layer_pro[18] = sol_layer_pro[18] + "%8.2f\n" \
                        %(0.00)
            #  ! 20  BDD  = BULK DENSITY(OVEN DRY)(t/m3)   (BLANK IF UNKNOWN)                
                    sol_layer_pro[19] = sol_layer_pro[19] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_drybulkdensity" %(layeridx+1)]))
            #  ! 21  PSP  = P SORPTION RATIO                   (BLANK IF UNKNOWN)                  
                    sol_layer_pro[20] = sol_layer_pro[20] + "%8.2f\n" \
                        %(0.00) 
            #  ! 22  SATC = SATURATED CONDUCTIVITY(mm/h)     (BLANK IF UNKNOWN)
                    sol_layer_pro[21] = sol_layer_pro[21] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_ksat" %(layeridx+1)]))
            #  ! 23  HCL  = LATERAL HYDRAULIC CONDUCTIVITY(mm/h)                
                    sol_layer_pro[22] = sol_layer_pro[22] + "%8.2f\n" \
                        %(0.00)
            #  ! 24  WPO  = INITIAL ORGANIC P CONC(g/t)      (BLANK IF UNKNOWN)                
                    sol_layer_pro[23] = sol_layer_pro[23] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_ptotal" %(layeridx+1)])-float(soldata[0]["l%i_ph2osoluble_r" %(layeridx+1)]))
            #  ! 25  DHN  = EXCHANGEABLE K CONC (g/t)                
                    sol_layer_pro[24] = sol_layer_pro[24] + "%8.2f\n" \
                        %(0.00)
            #  ! 26  ECND = ELECTRICAL COND (mmho/cm)                
                    sol_layer_pro[25] = sol_layer_pro[25] + "%8.2f\n" \
                        %(float(soldata[0]["l%i_ec" %(layeridx+1)]))
            #  ! 27  STFR = FRACTION OF STORAGE INTERACTING WITH NO3 LEACHING                                              
            #  !                                               (BLANK IF UNKNOWN)                
                    sol_layer_pro[26] = sol_layer_pro[26] + "%8.2f\n" \
                        %(0.00)
            #  ! 28  SWST = INITIAL SOIL WATER STORAGE (m/m)                
                    sol_layer_pro[27] = sol_layer_pro[27] + "%8.2f\n" \
                        %(0.00)
            #  ! 29  CPRV = FRACTION INFLOW PARTITIONED TO VERTICLE CRACK OR PIPE FLOW                
                    sol_layer_pro[28] = sol_layer_pro[28] + "%8.2f\n" \
                        %(0.00)
            #  ! 30  CPRH = FRACTION INFLOW PARTITIONED TO HORIZONTAL CRACK OR PIPE                                        
            #  !            FLOW                 
                    sol_layer_pro[29] = sol_layer_pro[29] + "%8.2f\n" \
                        %(0.00)
            #  ! 31  WLS  = STRUCTURAL LITTER(kg/ha)           (BLANK IF UNKNOWN)                
                    sol_layer_pro[30] = sol_layer_pro[30] + "%8.2f\n" \
                        %(0.00)
            #  ! 32  WLM  = METABOLIC LITTER(kg/ha)            (BLANK IF UNKNOWN)            
                    sol_layer_pro[31] = sol_layer_pro[31] + "%8.2f\n" \
                        %(0.00)
            #  ! 33  WLSL = LIGNIN CONTENT OF STRUCTURAL LITTER(kg/ha)(B I U)                
                    sol_layer_pro[32] = sol_layer_pro[32] + "%8.2f\n" \
                        %(0.00)
            #  ! 34  WLSC = CARBON CONTENT OF STRUCTURAL LITTER(kg/ha)(B I U) 
                    sol_layer_pro[33] = sol_layer_pro[33] + "%8.2f\n" \
                        %(0.00)
            #  ! 35  WLMC = C CONTENT OF METABOLIC LITTER(kg/ha)(B I U)
                    sol_layer_pro[34] = sol_layer_pro[34] + "%8.2f\n" \
                        %(0.00)
            #  ! 36  WLSLC= C CONTENT OF LIGNIN OF STRUCTURAL LITTER(kg/ha)(B I U)
                    sol_layer_pro[35] = sol_layer_pro[35] + "%8.2f\n" \
                        %(0.00)
            #  ! 37  WLSLNC=N CONTENT OF LIGNIN OF STRUCTURAL LITTER(kg/ha)(BIU)
                    sol_layer_pro[36] = sol_layer_pro[36] + "%8.2f\n" \
                        %(0.00)
            #  ! 38  WBMC = C CONTENT OF BIOMASS(kg/ha)(BIU)
                    sol_layer_pro[37] = sol_layer_pro[37] + "%8.2f\n" \
                        %(0.00)
            #  ! 39  WHSC = C CONTENT OF SLOW HUMUS(kg/ha)(BIU)
                    sol_layer_pro[38] = sol_layer_pro[38] + "%8.2f\n" \
                        %(0.00)
            #  ! 40  WHPC = C CONTENT OF PASSIVE HUMUS(kg/ha)(BIU)
                    sol_layer_pro[39] = sol_layer_pro[39] + "%8.2f\n" \
                        %(0.00)
            #  ! 41  WLSN = N CONTENT OF STRUCTURAL LITTER(kg/ha)(BIU)
                    sol_layer_pro[40] = sol_layer_pro[40] + "%8.2f\n" \
                        %(0.00)
            #  ! 42  WLMN = N CONTENT OF METABOLIC LITTER(kg/ha)(BIU)
                    sol_layer_pro[41] = sol_layer_pro[41] + "%8.2f\n" \
                        %(0.00)
            #  ! 43  WBMN = N CONTENT OF BIOMASS(kg/ha)(BIU)
                    sol_layer_pro[42] = sol_layer_pro[42] + "%8.2f\n" \
                        %(0.00)
            #  ! 44  WHSN = N CONTENT OF SLOW HUMUS(kg/ha)(BIU)
                    sol_layer_pro[43] = sol_layer_pro[43] + "%8.2f\n" \
                        %(0.00)
            #  ! 45  WHPN = N CONTENT OF PASSIVE HUMUS(kg/ha)(BIU)
                    sol_layer_pro[44] = sol_layer_pro[44] + "%8.2f\n" \
                        %(0.00)
            #  ! 46  FE26 = IRON CONTENT(%)
                    sol_layer_pro[45] = sol_layer_pro[45] + "%8.2f\n" \
                        %(0.00)
            #  ! 47  SULF = SULFUR CONTENT(%)                 
                    sol_layer_pro[46] = sol_layer_pro[46] + "%8.2f\n" \
                        %(0.00)
            #  ! 48  ASHZ = SOIL HORIZON(A,B,C)                                                                            
                    sol_layer_pro[47] = sol_layer_pro[47] + "%8s\n" \
                        %(" ")
            #   ! 49  CGO2 = O2 CONC IN GAS PHASE (g/m3 OF SOIL AIR)
                    sol_layer_pro[48] = sol_layer_pro[48] + "%8.2f\n" \
                        %(0.00)
            #   ! 50  CGCO2= CO2 CONC IN GAS PHASE (g/m3 OF SOIL AIR)                                                       
                    sol_layer_pro[49] = sol_layer_pro[49] + "%8.2f\n" \
                        %(0.00)
            #   ! 51  CGN2O= N2O CONC IN GAS PHASE (g/m3 OF SOIL AIR)                 
                    sol_layer_pro[50] = sol_layer_pro[50] + "%8.2f\n" \
                        %(0.00)

    for layproidx in range(3, 51):
        outf.writelines(sol_layer_pro[layproidx])
    outf.close()

def doSetup(hruinvar, idx, soldb, statename):

    # hruinvar = [0state, 1county, 2zipcode, 3soilmky,
    # 4landuse, 5slopegroupe, 6cellcount, 7avgslp, 8lat, 9long, 10dem, 11rowid_colid, 12bmpid]

    #exclude those soil as water
    soilname = " "
    selectdata = soldb.loc[soldb['mukey'] == int(hruinvar[3])]
    soldata = selectdata.to_dict('records')  
    soilname = soldata[0]["muname"]
    soldeparray = [soldata[0]["l1_layerdepth"],
                    soldata[0]["l2_layerdepth"],
                    soldata[0]["l3_layerdepth"],
                    soldata[0]["l4_layerdepth"],
                    soldata[0]["l5_layerdepth"],
                    soldata[0]["l6_layerdepth"],
                    soldata[0]["l7_layerdepth"],
                    soldata[0]["l8_layerdepth"],
                    soldata[0]["l9_layerdepth"],
                    soldata[0]["l10_layerdepth"]]
    soldeparray = map(float, soldeparray)

    if ((soilname == "Water") or (max(soldeparray) <0.02)):
        # or (hruinvar[4] == "8") exclude water landuse
        return()
    else:
        # Change directory to run directory and create current run directories.
        os.chdir(workdir + ("\\MPRUNS\\grouphru_map\\%s\\" %(statename)))
        try:
            if not os.path.exists(str(idx)):
                os.makedirs(str(idx))
        # There are no exceptions.
        except:
            pass

        currentdir = workdir + ("\\MPRUNS\\grouphru_map\\%s\\" %(statename)) + str(idx)
        # Attempt to copy inputs to current run directory.
        try:
            copyfile(workdir+"\\REQUIRED\\APEXFILE.DAT", currentdir + "\\APEXFILE.DAT")
            copyfile(workdir+"\\REQUIRED\\APEXCONT.DAT", currentdir + "\\APEXCONT.DAT")
            copyfile(workdir+"\\REQUIRED\\APEXDIM.DAT", currentdir + "\\APEXDIM.DAT")
            copyfile(workdir+"\\REQUIRED\\APEXRUN.DAT", currentdir + "\\APEXRUN.DAT")
            copyfile(workdir+"\\REQUIRED\\SOILCOM.DAT", currentdir + "\\SOILCOM.DAT")
            copyfile(workdir+"\\REQUIRED\\SITECOM.DAT", currentdir + "\\SITECOM.DAT")
            copyfile(workdir+"\\REQUIRED\\SUBACOM.DAT", currentdir + "\\SUBACOM.DAT")
            copyfile(workdir+"\\REQUIRED\\SOL.SOL", currentdir + "\\SOL.SOL")
            copyfile(workdir+"\\REQUIRED\\SIT.SIT", currentdir + "\\SIT.SIT")
            copyfile(workdir+"\\REQUIRED\\SUB.SUB", currentdir + "\\SUB.SUB")
            copyfile(workdir+"\\REQUIRED\\WINDWEPP.DAT", currentdir + "\\WINDWEPP.DAT")
            copyfile(workdir+"\\REQUIRED\\WPM1WEPP.DAT", currentdir + "\\WPM1WEPP.DAT")
            copyfile(workdir+"\\REQUIRED\\OPSCCOM_bmps.DAT", currentdir + "\\OPSCCOM_bmps.DAT")  
            copyfile(workdir+"\\REQUIRED\\OPSCCOM_ops.DAT", currentdir + "\\OPSCCOM_ops.DAT")   

        # Exit upon failure to copy.
        except IOError as e:
            print("Unable to copy file. %s" % e)
            sys.exit()
            
        # Modify input files.
        modifySubFile(hruinvar, idx, soldb, statename)
        modifySitFile(hruinvar, idx, soldb, statename)
        modifySolFile(hruinvar, idx, soldb, statename)

        # Modify APEX file location
        f = open("APEXFILE.DAT","r")
        ob = open("OPSCCOM_bmps.DAT","r")
        oo = open("OPSCCOM_ops.DAT","r")
        wi = open("WINDWEPP.DAT","r")
        wp = open("WPM1WEPP.DAT","r")

        fstr = f.read()
        obstr = ob.read()
        oostr = oo.read()
        wistr = wi.read()
        wpstr = wp.read()

        f.close()
        ob.close()
        oo.close()
        wi.close()
        wp.close()

        # replace the APEX files location with working directory
        fstr = fstr.replace("C:\\APEXMP\\REQUIRED\\", workdir + "\\REQUIRED\\")
        obstr = obstr.replace("C:\\APEXMP\\REQUIRED\\", workdir + "\\REQUIRED\\")
        oostr = oostr.replace("C:\\APEXMP\\REQUIRED\\", workdir + "\\REQUIRED\\")
        wistr = wistr.replace("C:\\APEXMP\\REQUIRED\\", workdir + "\\REQUIRED\\")
        wpstr = wpstr.replace("C:\\APEXMP\\REQUIRED\\", workdir + "\\REQUIRED\\")   
         
        # change opearation file name
        if (len(hruinvar) == 13):
            fstr = fstr.replace("OPSCCOM.DAT", "OPSCCOM_bmps.DAT")
        else:
            fstr = fstr.replace("OPSCCOM.DAT", "OPSCCOM_ops.DAT")   

        # Write the new files.
        outf = open("APEXFILE.DAT","w")
        outob = open("OPSCCOM_bmps.DAT","w")
        outoo = open("OPSCCOM_ops.DAT","w")
        outwi = open("WINDWEPP.DAT","w")
        outwp = open("WPM1WEPP.DAT","w")  
        outf.write(fstr)
        outoo.write(oostr)
        outob.write(obstr)
        outwi.write(wistr)
        outwp.write(wpstr)
        outf.close()
        outoo.close()
        outob.close()
        outwi.close()
        outwp.close()         

def doRun(idx, tsink, statename):

    # Change to root run directory and create the results file.
    currentdir = workdir + ("\\MPRUNS\\grouphru_map\\%s\\" %(statename)) + str(idx)
    os.chdir(currentdir)
        
    # Run the apex runs.
    runlog = open(currentdir + "\\runlog.txt", "wb")
    runerr = open(currentdir + "\\runerr.txt", "wb")
    apex = workdir + "\\apex1501.exe"
    subprocess.call(apex, stdout=runlog, stderr=runerr, shell=True)
    runlog.close()
    runerr.close()

    os.remove("Results.MSA")	
    os.remove("Results.MWS")	
    os.remove("Results.OUT")	
    os.remove("Results.AWP")    	
    os.remove("APEXCONT.DAT")	
    os.remove("APEXDIM.DAT")	
    os.remove("APEXFILE.DAT")	
    os.remove("APEXRUN.DAT")	
    os.remove("SITECOM.DAT") 	
    os.remove("SOILCOM.DAT")	
    os.remove("SUBACOM.DAT")
    os.remove("OPSCCOM_bmps.DAT")
    os.remove("OPSCCOM_ops.DAT")
    os.remove("WINDWEPP.DAT")
    os.remove("WPM1WEPP.DAT")
    os.remove("SOL.SOL")
    os.remove("SUB.SUB")
    os.remove("SIT.SIT") 	
    os.remove("runerr.txt")	
    os.remove("runlog.txt")
    for filename in glob.glob("./fort*"):
        os.remove(filename) 
    
    # Print progress to terminal.
    if (float(idx) % 25 == 0):
        now = datetime.datetime.now()
        telap = now - tsink
        hrelap = int(telap.total_seconds() // 3600)
        mtelap = int((telap.total_seconds() - hrelap*3600) // 60)
        scelap = int((telap.total_seconds() - hrelap*3600 - mtelap*60) // 1)
        print("Run #%s Completed.    Elasped Time (HH:MM:SS): %02d:%02d:%02d" % (idx, hrelap, mtelap, scelap))
        sys.stdout.flush()

def parseoutputs(idx, statename):

    # Change to root run directory and create the results file.
    os.chdir(workdir)
    currentdir = workdir + ("\\MPRUNS\\grouphru_map\\%s\\" %(statename)) + str(idx)

    # Set default values for missing results.
    precip = -999
    runoff = -999
    soilloss = -999
    TN = -999
    TP = -999
    
    # Populate results from .wss file.
    if (os.path.exists(currentdir + "\\Results.WSS") is True) and (os.path.getsize(currentdir + "\\Results.WSS") != 0):
        wss = open(currentdir + "\\Results.WSS", "r")
        wssout = wss.readlines()
        wsslastline = wssout[-1].split()
        wssprcpline = wssout[-24].split()
        if ('*' not in wsslastline) and ('*' not in wssprcpline):
            precip = str(wssprcpline[13])
            runoff = str(wsslastline[5])
            soilloss = wsslastline[-13]
            TN = str(round(float(wsslastline[-8])+float(wsslastline[-7])+float(wsslastline[-4])+float(wsslastline[-3])+float(wsslastline[-2])+float(wsslastline[-1]),2))	
            TP = str(round(float(wsslastline[-5]) + float(wsslastline[-6]),2))
        wss.close()

    # Return populated results.
    return [precip, runoff, soilloss, TN, TP]

def main():
    
    # Change to working directory.
    os.chdir(workdir)

    # Get the current datetime and create the run result file.
    now = datetime.datetime.now()
    tstarttotal = str(now.year) + "-" + str(now.month) + "-" + str(now.day) + "-" + str(now.hour) + "-" + str(now.minute) + "-" + str(now.second)

    # This part can be change to user selection input with the apexmp wrapper
    # Create empty lists of inputs.
    ops_or_bmps = ''
    bmps = ''
    # Read the configuration file.
    with open("config.txt", "r") as config:
        for line in config:
            parts = re.split(":|\n",line)
            if (parts[0].startswith("ops or bmps")):
                ops_or_bmps = parts[1]                
            if (parts[0].startswith("bmps")):
                bmps = parts[1]
    # Exit upon empty inputs.
    if (len(ops_or_bmps) == 0):
        print("Did not make choice of ops or bmps.")
        sys.exit()
    if (len(bmps) == 0):
        print("No bmps specified.")
        sys.exit()

    # Create the run folder
    try:
        if not os.path.exists("MPRUNS\\grouphru_map"):
            os.makedirs("MPRUNS\\grouphru_map")
        if not os.path.exists("RESULTS\\grouphru_map"):
            os.makedirs("RESULTS\\grouphru_map")
    # There are no exceptions.
    except:
        pass

    # Get the list of all of the state, county, and zip combinations in US
    stctyziplst = {}
    fid = open(workdir+"\\INPUTS\\usstctyziplatlong2sql.txt", "r")
    lif = fid.readlines()
    fid.close()
    for sid in range(len(lif)):
        lif[sid] = lif[sid].split(",")    
        lif[sid][1] = lif[sid][1].replace(" ", "")
        lif[sid][1] = lif[sid][1].replace(".", "")
        lif[sid][1] = lif[sid][1].replace("-", "")
        lif[sid][1] = lif[sid][1].replace("'", "")

        skey = "%s_%s_%s" %(lif[sid][4],
                            lif[sid][1],
                            lif[sid][2])
        
        stctyziplst[skey] = lif[sid][3:]  

    # Get state and county list need to run
    stctys = []
    st = []
    stlst = []
    stctys = glob.glob("%s/*.shp" %(workdir + "\\INPUTS\\county\\allcty"))  

    for cid in range(len(stctys)):
        stctys[cid] = os.path.split(stctys[cid])[-1][:-4]
        st.append(stctys[cid].split("_")[0])
    
    # Get the state list
    stlstall = ["Alabama","Arizona","Arkansas","California","Colorado","Connecticut",
        "Delaware","DistrictofColumbia","Florida","Georgia","Idaho","Illinois",
        "Indiana","Iowa","Kansas","Kentucky","Louisiana","Maine","Maryland",
        "Massachusetts","Michigan","Minnesota","Mississippi","Missouri","Montana",
        "Nebraska","Nevada","NewHampshire","NewJersey","NewMexico","NewYork",
        "NorthCarolina","NorthDakota","Ohio","Oklahoma","Oregon","Pennsylvania",
        "RhodeIsland","SouthCarolina","SouthDakota","Tennessee","Texas","Utah",
        "Vermont","Virginia","Washington","WestVirginia","Wisconsin","Wyoming"]

    # Create the the state-county dictionary with state names as keys and state_county list as values
    for i in stlstall:
        if i in st:
            stlst.append(i)
    stctydict = {stlstkey: [stcty for stcty in stctys if stcty.startswith(stlstkey)] for stlstkey in stlst}

    # Set up loop of runs for each state
    for stidx in range(len(list(stctydict.keys()))):
        statename = list(stctydict.keys())[stidx]
        # Create the run folder
        try:
            if not os.path.exists(workdir+ ("\\MPRUNS\\grouphru_map\\%s" %(statename))):
                os.makedirs(workdir+ ("\\MPRUNS\\grouphru_map\\%s" %(statename)))
        # There are no exceptions.
        except:
            pass
        
        # Get the current datetime and create the run result file.
        now = datetime.datetime.now()
        tstart = str(now.year) + "-" + str(now.month) + "-" + str(now.day) + "-" + str(now.hour) + "-" + str(now.minute) + "-" + str(now.second)
        tsink = now
        xout = open(workdir + "\\RESULTS\\grouphru_map\\" + statename + "_" + tstart + ".csv","w")
        xout.write("RunID,State,County,Zipcode,Soil,Landuse,Slopegroup,Aarea(m2),Slope(%),Latitude,Longitude,Elevation(m),Rowid_Colid,Operation,Precipitation(mm/yr),Runoff(mm/yr),Soil Loss(t/ha),Total N(kg/ha),Total P(kg/ha)\n")
        xout.close()

        # Combine inputs for the job list.
        th1 = datetime.datetime.now()
        print("\n\rhrulist prepartion of " + statename + " has begun at " + str(th1) + " ...\n\r")

        # Reset the run counter to 1.
        idx = 0
        hruinvar = []
        # Get the county list in the current state
        stctylst = stctydict[statename]

        # Create the multiprocessing job list.
        for stctyidx in range(len(stctylst)):
            hrulsts = ctyData(stctyziplst, stctylst[stctyidx])      

            for hruidx in range(len(list(hrulsts.keys()))):             
                # change ops here
                if ops_or_bmps == "ops":
                    # Get inputs.
                    hruinpart1 = []
                    hruinpart2 = []
                    hruinvarlst = []
                    hruinpart1 = list(hrulsts.keys())[hruidx].split("_")
                    hruinpart2 = hrulsts[list(hrulsts.keys())[hruidx]]
                    hruinvarlst = hruinpart1 + hruinpart2
                    hruinvar.append(hruinvarlst)
                    idx = idx + 1
                else:
                    for bmpid in range(int(bmps[0])):    
                        hruinpart1 = []
                        hruinpart2 = []
                        bmplst = []
                        hruinvarlst = []
                        hruinpart1 = list(hrulsts.keys())[hruidx].split("_")
                        hruinpart2 = hrulsts[list(hrulsts.keys())[hruidx]]
                        bmp = bmpid + 1
                        bmplst = [str(bmp)]
                        hruinvarlst = hruinpart1 + hruinpart2 + bmplst
                        hruinvar.append(hruinvarlst)
                        idx = idx + 1                    

        th2 = datetime.datetime.now()
        print("\n\rhrulist prepartion of " + statename + " has completed at " + str(th2) + " .\n\r")

        # hruinvar = [0state, 1county, 2zipcode, 3soilmky,
        # 4landuse, 5slopegroupe, 6cellcount, 7avgslp, 8lat, 9long, 10dem, 11rowid_colid, 12bmpid]

        # Prepare soildatabase for setup
        soildatabase = pd.read_csv(workdir+"\\INPUTS\\ssurgo2apex.csv")
        mukeys = []
        for i in range(len(hruinvar)):
            hru = hruinvar[i]
            mukeys.append(hru[3])
        rows = soildatabase.mukey.isin(mukeys)
        soildb = soildatabase[rows]

        # Return to the root working directory.
        os.chdir(workdir)

        # Create run job pool.
        s_list = []
        r_list = []
        for i in range(len(hruinvar)):
            s_list.append((hruinvar[i], i, soildb, statename))
            r_list.append((i, tsink, statename))

        # Clear the terminal output.
        print("\n\r" * 30)

        # Determine a suitable number of cores to use.
        cores = cpu_count()
        nworkers_75 = math.floor(cores/4*3)
        nworkers_4b = cores - 4
        nworkers_min = 1
        nworkers_max = 32
        nworkers = int(max(nworkers_75, nworkers_4b, nworkers_min))
        nworkers = int(min(nworkers, nworkers_max))

        # Create the worker pool to setup for model runs.
        tps1 = datetime.datetime.now()
        print("\n\rParallel setup of " + statename + " of " + str(idx) + " runs has begun at " + str(tps1) + " ...\n\r")
        sys.stdout.flush()
        workers = Pool(nworkers)
        for i in range(len(s_list)):
            workers.apply_async(doSetup, args=s_list[i])
        workers.close()
        workers.join()
        tps2 = datetime.datetime.now()    
        print("\n\rParallel setup of " + statename + " has completed at " + str(tps2) + " .\n\r")

        # Create the worker pool to execute model runs.
        tpr1 = datetime.datetime.now()
        print("\n\rParallel execution of " + statename + " of " + str(idx) + " runs has begun at " + str(tpr1) + " ...\n\r")
        sys.stdout.flush()
        workers = Pool(nworkers)
        for i in range(len(r_list)):
            workers.apply_async(doRun, args=r_list[i])
            sys.stdout.flush()
        workers.close()
        workers.join()
        tpr2 = datetime.datetime.now()
        print("\n\rParallel execution of " + statename + " has completed at " + str(tpr2) + " .\n\r")

        # Open results file.
        tg1 = datetime.datetime.now()
        print("\n\rGathering of " + statename + " of " + str(idx) + " results has begun at " + str(tg1) + " ...\n\r")
        sys.stdout.flush()
        xout = open(workdir + "\\RESULTS\\grouphru_map\\" + statename + "_" + tstart + ".csv", "a")

        # Read results from runs and store.
        for i in range(len(hruinvar)):

            # Get run parameters.
            state = str(hruinvar[i][0])
            county = str(hruinvar[i][1])
            zipcode = str(hruinvar[i][2])
            soil = str(hruinvar[i][3])
            landuse = str(hruinvar[i][4])
            slopegroup = str(hruinvar[i][5])
            area = str(hruinvar[i][6]*30*30)
            slope = str(hruinvar[i][7]/hruinvar[i][6]*100)
            if ops_or_bmps == 'ops':
                operation = str(1)
            else:
                operation = str(hruinvar[i][12])
            latitude = str(float(hruinvar[i][8]))
            longitude = str(float(hruinvar[i][9]))
            elevation = str(hruinvar[i][10]/hruinvar[i][6])
            rowid_colid = str(hruinvar[i][11])

            # Parse outputs.
            res = parseoutputs(i, statename)
            outstr = (str(i) + "," + state + "," + county + "," + zipcode + "," + soil 
                        + "," + landuse + "," + slopegroup + "," + area + "," + slope + "," 
                         + latitude + "," + longitude + "," + elevation + "," + rowid_colid + "," + operation + ","
                        + str(res[0]) + ","+ str(res[1]) + ","+ str(res[2]) + ","+ str(res[3]) + ","+ str(res[4]) + "\n")

            # Write results to file.
            xout.write(outstr)
        
        # Close results file.
        xout.close()
        tg2 = datetime.datetime.now()
        print("Gathering of " + statename + " has completed at " + str(tg2) + " .\n\r")

        # Get the end time.
        now = datetime.datetime.now()
        tend = str(now.year) + "-" + str(now.month) + "-" + str(now.day) + "-" + str(now.hour) + "-" + str(now.minute) + "-" + str(now.second)

        # Print the start and end times.
        print("\n\rStart time of " + statename + " : " + tstart)
        print("\n\rEnd time of " + statename + " : " + tend)

    # Get the total end time.
    now = datetime.datetime.now()
    tendtotal = str(now.year) + "-" + str(now.month) + "-" + str(now.day) + "-" + str(now.hour) + "-" + str(now.minute) + "-" + str(now.second)

    # Print the total start and end times.
    print("\n\rStart time: " + tstarttotal)
    print("\n\rEnd time:   " + tendtotal)   

    # Exit upon completion.
    sys.exit()


#############################################################################
################################ RUN PROGRAM ################################
#############################################################################

if __name__ == '__main__':
    main()
