# -*- coding: utf-8 -*-
#############################################################################
############################## PROGRAM METADATA #############################
#############################################################################

#  Last Updated by: Ryan McGehee and Feng Pan
#  Last Updated on: 29 November 2020
#  Purpose: This is a wrapper program to run the component scripts of APEXMP
#           from a simple configuration file.
#
#  Contributors: Component scripts were written by Feng Pan, Ryan McGehee,
#                and Qingyu Feng (in order of contribution). Contributions
#                were documented in program metadata for each script.

#############################################################################
############################# INSTRUCTIONS TO RUN ###########################
#############################################################################

# Requirements: This script must be in the APEXMP directory accompanied by
#               the following files and directories. See the component
#               scripts for further requirements of each script.
#
# Files or directory:    
#           SRC                         (APEXMP source code)
#           REQUIRED                    (provided with APEXMP source code)
#           INPUTS                      (directories of county, dem, lanuse, 
#                                       slope, soil, and zipcode; soil-database
#                                       file, zipcode-database file)
#           MPRUNS                      (will be generated by APEXMP)
#           RESULTS                     (will be generated by APEXMP)
#
# Disk Space: At least 4 MB of space per run is required for keeping all run
#             outputs. The requirement is much smaller if one does not need to 
#             preserve the monthly, average monthly, average annualand output files. 
#             This code can be modified to remove those files after each run in 
#             order to increase run limits.
# 
# 
##############################################################################
############################## IMPORT LIBRARIES ##############################
##############################################################################

import os, sys, string, math, subprocess
from multiprocessing import cpu_count, Pool, Process


#############################################################################
############################## GLOBAL VARIABLES #############################
#############################################################################

workdir = os.path.dirname(os.path.realpath(sys.argv[0]))


#############################################################################
############################## DEFINE FUNCTIONS #############################
#############################################################################

def printStartupInformation():

    print("\n" * 30)
    print("****************************************************************************")
    print("  Agricultural Policy Extender Model Multiprocessing Program (APEXMP) v1.0  ")
    print("****************************************************************************")
    print("\n")
    print("\
        Copyright (c) 2020 Feng Pan, Qingyu Feng, and Ryan McGehee\n\
        \n\
        This program is free software: you can redistribute it and/or modify\n\
        it under the terms of the GNU General Public License as published by\n\
        the Free Software Foundation (GNU GPL v3.0).\n\
        \n\
        This program is distributed in the hope that it will be useful,\n\
        but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
        GNU General Public License for more details.\n\
        \n\
        You should have received a copy of the GNU General Public License\n\
        along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\
        \n\
        Please provide an appropriate citation in any published work as follows:\n\
        \n\
        Pan, F., Q. Feng, R.P. McGehee, B.A. Engel, D.C. Flanagan, and J. Chen.\n\
            <PUBLICATION YEAR>\n\
            <TITLE>\n\
            <JOURNAL INFO>\n\
            <DOI>\n\
            Repository available at: https://github.com/ryanpmcg/APEXMP\n\
        \n\
        Corresponding Author: F. Pan\n\
        E-mail: blah@blah.com\n\
        ")
    print("\n")

def readConfigurationFile():

    # Parse configuration file.
    with open("config.txt", "r") as ins:
        for line in ins:
            parts = line.split("::")
            if (len(parts) == 2):
                if (parts[0].startswith("Python")):
                    pythonExe = parts[1].lstrip().rstrip()
                if (parts[0].startswith("Use BMPs")):
                    ubmp = parts[1].lstrip().rstrip()
                if (parts[0].startswith("BMP Selection")):
                    bmps = parts[1].lstrip().rstrip()
                if (parts[0].startswith("Distributed")):
                    dist = parts[1].lstrip().rstrip()
                if (parts[0].startswith("Create Maps")):
                    maps = parts[1].lstrip().rstrip()
                if (parts[0].startswith("Delete Output")):
                    delete = parts[1].lstrip().rstrip()
                if (parts[0].startswith("Verbose")):
                    verb = parts[1].lstrip().rstrip()
                if (parts[0].startswith("Developer Mode")):
                    devm = parts[1].lstrip().rstrip()

    # Exit upon empty inputs.
    if (len(pythonExe) == 0):
        print("No python path specified.")
        sys.exit()
    if (len(ubmp) == 0):
        print("No BMP usage option specified.")
        sys.exit()
    if (len(bmps) == 0):
        print("No BMP selection specified.")
        sys.exit()
    if (len(dist) == 0):
        print("No distributed option specified.")
        sys.exit()
    if (len(maps) == 0):
        print("No mapping option specified.")
        sys.exit()
    if (len(delete) == 0):
        print("No deletion option specified.")
        sys.exit()
    if (len(verb) == 0):
        print("No verbosity option specified.")
        sys.exit()
    if (len(devm) == 0):
        print("No development option specified.")
        sys.exit()

    # Convert boolean strings to boolean values.
    ubmp = (ubmp == "T")
    dist = (dist == "T")
    maps = (maps == "T")
    delete = (delete == "T")
    verb = (verb == "T")
    devm = (devm == "T")

    # Exit upon incorrect readings.
    if ((type(ubmp) == type(True)) and (type(dist) == type(True)) and (type(maps) == type(True)) and (type(delete) == type(True)) and (type(verb) == type(True)) and (type(devm) == type(True))):
        if (verb == True):
            print("All logical parameters read correctly.")
    else:
        print("Incorrect boolean string values. Use 'T' or 'F' only.")
        sys.exit()
    
    # Return values.
    return ubmp, bmps, dist, maps, delete, verb, devm, pythonExe

def determineOptimalCores():
    cores = cpu_count()
    nworkers_90 = math.floor(float(cores)/10*9)
    nworkers_min = 1
    nworkers = int(max(nworkers_90, nworkers_min))
    return nworkers

def main():

    printStartupInformation()
    p = readConfigurationFile() # p components (index=content): 0=BMPs, 1=BMPtype, 2=Distributed, 3=Map, 4=Delete, 5=Verbose, 6=DevMode, 7=PythonExe
    n = determineOptimalCores()

    # Create standard arguments (a string of parameters). Parameters: workDir, delete, verb, ubmp, bmps, devm, nworkers
    pString = str(workdir) + " " + str(int(p[4])) + " " + str(int(p[5])) + " " + str(int(p[0])) + " " + str(int(p[1])) + " "+ str(int(p[6])) + " " + str(n)

    # Run user-specified options for all grid cells (distributed).
    if (p[2] == True):
        subprocess.call(str(p[7]) + " ./SRC/prepareDistributed.py " + pString, shell=True)
        subprocess.call(str(p[7]) + " ./SRC/executeDistributed.py " + pString, shell=True)
        subprocess.call(str(p[7]) + " ./SRC/gatherDistributed.py " + pString, shell=True)
        if (p[3] == True):
            subprocess.call(str(p[7]) + " ./SRC/mapDistributed.py " + pString, shell=True)

    # Run user-specified options for lumped grid cells (semi-distributed).
    else:
        subprocess.call(str(p[7]) + " ./SRC/prepareSemiDistributed.py " + pString, shell=True)
        subprocess.call(str(p[7]) + " ./SRC/executeSemiDistributed.py " + pString, shell=True)
        subprocess.call(str(p[7]) + " ./SRC/gatherSemiDistributed.py " + pString, shell=True)
        if (p[3] == True):
            subprocess.call(str(p[7]) + " ./SRC/mapSemiDistributed.py " + pString, shell=True)


#############################################################################
################################ RUN PROGRAM ################################
#############################################################################

if __name__ == '__main__':
    main()
