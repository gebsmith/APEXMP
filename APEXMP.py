# -*- coding: utf-8 -*-
#############################################################################
############################## PROGRAM METADATA #############################
#############################################################################

#  Last Updated by: Ryan McGehee and Feng Pan
#  Last Updated on: 23 November 2020
#  Purpose: This is a wrapper program to run the component scripts of APEXMP
#           from a simple configuration file.
#
#  Contributors: Component scripts were written by Feng Pan, Ryan McGehee,
#                and Qingyu Feng (in order of contribution). Contributions
#                were documented in program metadata for each script.

#############################################################################
############################# INSTRUCTIONS TO RUN ###########################
#############################################################################

# Requirements: This script must be in the APEXMP directory accompanied by
#               the following files and directories. See the component
#               scripts for further requirements of each script.
#
# Files or directory:    
#           SRC                         (APEXMP source code)
#           REQUIRED                    (provided with APEXMP source code)
#           INPUTS                      (directories of county, dem, lanuse, 
#                                       slope, soil, and zipcode; soil-database
#                                       file, zipcode-database file)
#           MPRUNS                      (will be generated by APEXMP)
#           RESULTS                     (will be generated by APEXMP)
#
# Disk Space: At least 4 MB of space per run is required for keeping all run
#             outputs. The requirement is much smaller if one does not need to 
#             preserve the monthly, average monthly, average annualand output files. 
#             This code can be modified to remove those files after each run in 
#             order to increase run limits.
# 
# 
##############################################################################
############################## IMPORT LIBRARIES ##############################
##############################################################################

import os, glob, subprocess, sys


#############################################################################
############################## GLOBAL VARIABLES #############################
#############################################################################

workdir = sys.argv[1]
spacing = 0


#############################################################################
################################ RUN PROGRAM ################################
#############################################################################

# Announce program start
print("\n" * spacing)
print("Preparing inputs for every grid cell.")
print("\n" * spacing)


# # 1. choose conventional operations(0) or BMPs(1), and input BMPs number(-integer-) if choose 1
#   user return 0: record and input it as 'ops' for ops_or_bmps to call_apex_mp
#   user return 1 and -interger-: record and input them as 'bmps' for ops_or_bmps and '-interger-' for bmps to call_apex_mp

# 2. choose between every grid(0) or grouped grids(1)
#   user return 0: select prepare_data_everyhru.py and call_apex_mp_everyhru_map.py to run
#   user return 1: select prepare_data_grouphru.py and call_apex_mp_grouphru_map.py to run

# 3. choose table results(0), map results(1), or both(2)
#   user return 0-0: select results_analysis_everyhru.py to run
#   user return 0-1: select results_analysis_everyhru_map.py to run
#   user return 0-2: select both ones above to run
#   user return 1-0: select results_analysis_grouphru.py to run
#   user return 1-1: select results_analysis_grouphru_map.py to run
#   user return 1-2: select both ones above to run

# 4. After user make all the selection (and input), run the selected scripts.

        # Determine a suitable number of cores to use.
        cores = cpu_count()
        nworkers_75 = math.floor(cores/4*3)
        nworkers_4b = cores - 4
        nworkers_min = 1
        nworkers_max = 32
        nworkers = int(max(nworkers_75, nworkers_4b, nworkers_min))
        nworkers = int(min(nworkers, nworkers_max))